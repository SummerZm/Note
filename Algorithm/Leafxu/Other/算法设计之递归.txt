如何设计递归函数
=============================
1. 递归程序的组成
	a. 递归子结构 -- 可重入的主体部分
	b. 递归的退出条件和退出处理
	c. 自我再触发机制

2. 递归程序的常用模式
	a. 同一问题的结构变形模式
		-- 常用于穷举法: 
		-- 例子:深度优先遍历算法-图的遍历
		-- 例子:三个水桶倒水
	
	b. 多阶段组合模式
		-- 各个部分关系紧密，无法用通过拆分子问题的方式消减问题的规模
		-- 问题的解决需要多个操作步骤，每个操作步骤完成问题的一部分，当所有的操作都完成后问题才能解决。
		-- 例子：假如我们需要从 1 ~ 9 共 9 个数字中任选四个不同的数组成一个排列，有多少种结果吗？
			bool IsNumberUsed(int num[], int idx, int i)
			{
				for (int k = 0; k < idx; k++)
				{
					if (num[k] == i)
					{
						return true;
					}
				}
				return false;
			}

			void EnumNumber(int num[], int idx)
			{
				if (idx > 3) //枚举的有效 idx 是 0-3，超过 3 了就是退出条件
				{
					return;
				}
				//对当前 idx 位置用数字 1-9 尝试
				for (int i = 1; i <= 9; i++)
				{
					if (!IsNumberUsed(num, idx, i))
					{
						num[idx] = i;
						EnumNumber(num, idx + 1); //继续枚举下一个位置
					}
				}
			}
	
	c. 分解子问题模式
		-- 递归函数的参数需要被设计成能够反映问题的规模的一组参数 [快速排序算法|大整数乘法]
			
3. 递归程序的优点和缺点
	a. 优点: 代码简洁、优雅，最终实现的算法代码有种类似用自然语言描述的问题解决方案的效果。
	b. 缺点: 递归函数调用的效率和对栈空间的依赖。
		-- 函数调用的效率主要是参数入栈和出栈以及恢复栈平衡的开销
		-- 使用类似 fastcall 这样的函数调用约定，用寄存器传递函数参数能在一定程度上提高函数调用的性能。
		-- 递归程序对栈空间的依赖主要是两个方面
			--> 一个是函数参数入栈需要占用栈空间
			--> 一个是函数内部的局部变量
			--> 这些都会限制递归函数调用的深度，进而影响到这个递归程序能解决的问题的规模。
		
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	