爱因斯坦问题
=========================================================================
A. 不同问题的穷举法算法实现最大的差异点就是搜索算法的不同
    a. 线性空间的搜索
    b. 树状空间的搜索
    c. 二维表空间的搜索
        1. 对二维表中的每个元素进行枚举遍历，依次确定每个表格元素的值
        2. 当二维表中所有表格元素的值都确定后
            -- 检查其结果是否符合问题解的要求，如果满足要求，则输出一个结果
            -- 如果不满足要求，则按照一定的顺序继续遍历各个表格元素的值。 
            -- 类似的问题，或三维表空间的问题，都可以用类似的方法设计搜索算法。

B. 处理过程
    a.  问题的状态与数据模型 
        -- 如何确定问题的状态是二维表？
        -- 如何用代码呈现二维表模型？
        -- 设计这个问题的数据模型的时候，不仅要考虑是否能够实现对解空间的穷举遍历，还要考虑是否能简单高效地判断解的状态是不是正确的解

    b. 二维表线索模型定义
        -- 第一类是描述某些属性之间具有固定绑定关系的线索。
        -- 第二类描述元素所在的“组”具有相邻关系的线索，相邻关系的描述中也有两组 TLV 的信息。
        -- 第三类线索，无法建立统一的数学模型，只能在枚举算法进行过程中直接使用它们过滤掉一些不符合条件的组合结果。[融入到枚举过程中]
        -- 线索模型定义的技巧: CheckAllGroupsBind() 函数和 CheckAllGroupsRelation() 函数的实现非常简单，检查算法只需要遍历 binds 数组和 relations 数组即可，避免了写很多 if…else 分支。

    c. 全排列不能有重复
        -- 不能有类似{ COLOR_BLUE,COLOR_GREEN,COLOR_WHITE,COLOR_GREEN,COLOR_YELLOW }这样的组合结果

C. 数学分析:
    a. 房子颜色:    4！= 24 个颜色组合结果 -- 绿房子和白房子有稳定的绑定关系
    b. 国籍类型:    4！= 24 个国籍组合结果 -- 第一个房子住的人始终是挪威人
    c. 饮料类型:    4！= 24 个饮料组合类型 -- 住在中间那个房子里的人喝牛奶
    d. 宠物种类:    5！= 120
    e. 香烟品牌:    5！= 120
    f. 总计:  199065600 -- 大约两亿个状态 -- 耗时： 5s
    g. 穷举法是一个低效的方法。对于更大规模的问题，应尽量避免使用穷举法。


