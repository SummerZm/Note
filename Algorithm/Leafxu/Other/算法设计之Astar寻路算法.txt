A*算法
=============================================
A. 求最短路径的搜索算法
B. Dijkstra算法与A*算法的区别
	a. Dijkstra 算法比较直接，上来就是 BFS 搜索
		1. 从起点开始一圈一圈向外扩张搜索	
	b. A* 算法则用了一点“启发”技术
	
C. 如何将A*算法与带权有向图连接起来
	a. 将小方格描述的二维模拟地图转化成带权有向图
	
D. A*算法解析
	a. F(n) = G(h) + H(n)
		1. G(n) 是从起点到当前节点 n 的实际代价
		2. H(n) 是从当前节点 n 到终点的距离评估值
			-- H(n) 是 A* 算法的距离估计值，A* 算法需要一个距离评估函数来计算这个值
			--  常见的评估距离函数：
				-> 曼哈顿距离
					--> 数学上描述曼哈顿距离是两个点在各个坐标轴上的距离差值的总和
					
				-> 欧式几何平面距离.
					--> 数学定义: n 维空间中两个点之间的真实距离（几何距离）
					
				-> 切比雪夫距离
					--> 对于两个向量 p 和 q，其切比雪夫距离就是向量中各个分量差的绝对值中最大的那一个
					
		3. F(n)评估函数
			-- 当 H(n) 的计算结果很大的时候，G(n) 的值实际上就可以被忽略，这就使得 A* 算法还是呈现一种 Best-First 算法的效果。
			-- F(n) 评估函数中 G(n) 和 H(n) 的权重是一样的，很多 A* 算法的实现算法实际上是赋予这两个函数不同的权重系数，以避免上述的情况。
			-- 很多论文都有对 F(n) 评估函数中 G(n) 和 H(n) 的权重系统的讨论，通过调整 G(n) 和 H(n) 函数，可以使得 A* 算法在速度和准确性之间获得一个折中的效果。
		
	b. A*算法的搜索过程需要两个表
		1. Open表存放当前已经被发现，但是还没有搜索过的节点
		2. Close 表，存放已经搜索过的节点
		
	b. 算法步骤
		1. 初始化 Open 表和 Close 表，将起点加入到 Open 表中。
		2. 从 Open 表中取出当前 F(n) 值最小的节点作为当前搜索节点 U，将 U 节点加入到 Close 表中。
		3. 对于每一个与 U 可连通的节点（障碍物不相通）V，考察 V：
			-- 如果 V 已经在 Close 表中，则对该节点不做任何处理
			-- 如果 V 不在 Open 表中，则计算 F(V)，将 V 的前驱节点设置为 U 并将 V 加入到 Open 表中
			-- 如果 V 在 Open 表中，比较 G(U) + 1 与 G(V) 的大小（H(V) 的值是不变的），如果 G(U) + 1 < G(V)，则令 G(V) = G(U) + 1，同时将 V 的前驱节点设置为 U
			-- 重复步骤（2）和（3），直到第（2）步得到的搜索节点 U 就是终点为止
			
	e. 算法实现
		1. "顶点"数据模型
			struct ANODE
			{
				int i;
				int j;
				double g;  // 评估函数G的值
				double h;  // 评估函数H的值
				int prev_i; // 前驱节点的坐标
				int prev_j; // 前驱节点的坐标
			};
		
		2. Open 表和 Close 表的数据模
			-- Open 表的主要操作就是每次从中取出 F(n) 值最小的那个顶点，这意味着，如果 Open 表本身是个有序表
			-- 无论 C++ 还是 Java，都提供了内建排序机制的“集合”数据结构，本算法实现我们用 C++ 的 std::multiset
			-- 主要操作就是将一个顶点加入到 Close 表中和判断一个顶点是否在 Close 表中
			-- 因此，Close 表用一般的线性表就可以了，这里我们使用 C++ 的 std::vector。
		
D. 其他
	a. Best-First策略
		1. 其启发策略采用的是贪心原则，每次总是找与目的点最近的方向，
		2. 这使得在有障碍物的地图上，往往得到的路径不是最短路径。
		
	b. A* 算法兼有 Dijkstra 算法和 BFS 算法的特点，在速度和准确性之间具有很大的灵活性。
		除了调整 G(n) 和 H(n) 获得不同效果，A* 算法还有很多提高效率的改进算法，
		比如在地图很大的情况下，可以使用二叉堆来维护 Open 表以获得更好的效率。
		对于环境和权重都不断发生变化的动态网络，还有动态 A* 算法（又称 D* 算法）。
		
	c. A* 算法在游戏软件中也得到了广泛的应用，它们都是很简单的算法，但都得到了广泛的应用。
		
		
		
		
		
		
		
		
		
		
		
		
		
	
	