匈牙利算法与二分图的最大匹配
=================================================
A. 关于二分图有很多概念，比如匹配、完全匹配、最大匹配等。
B. 人们使用匈牙利算法都是根据自己问题域的数据模型，利用算法原理实现具体的算法。
C. 二分图 G=(V,E) 是这样的一个图，它的顶点集合 V 可以划分为 X 和 Y 两个集合，它的边集合 E 中的每条边都有一个端点在 X 集合，另一个端点在 Y 集合。
D. 判断二分图的关键是看点集是否能分成两个独立的点集。 【如果一个图的边形成了三角形，那它一定不是二分图】
E. 匹配的概念
    a. 匹配： 对于一个二分图 G=(V,E) 中部分边组成的子集 M，如果 M 的边集中任意两条边都不依附于同一个顶点，则称 M 是一个匹配
        1. 首先匹配是一个边的集合，并且不唯一；
        2. 其次，匹配M中没有任何两条边有公共的顶点。
        3. 一一映射
    b. 最大匹配： 对于一个二分图 G=(V,E) 的所有匹配中，所含匹配边数最多的匹配，称为这个图的最大匹配，最大匹配所包含的边数就是二分图的最大匹配数。
    c. 完全匹配： 如果一个二分图 G=(V,E) 的最大匹配，恰好连接了图中所有的顶点，也就是说所有的顶点都有属于最大匹配的边与之相连，则称这个最大匹配是完全匹配，或完美匹配。

F. 最大匹配和匈牙利算法
    a. 匈牙利算法是埃德蒙德斯（Edmonds）在 1965 年提出的一个简化的最大流算法，该算法根据二分图匹配这个问题的特点将最大流算法进行了简化。
    b. 匈牙利算法不区分图中的源点和汇点，也不关心边的方向，因此不需要复杂的网络图模型，正因为如此，使得匈牙利算法成为一种很简单的二分匹配算法。
    c. 匈牙利算法的关键是寻找增广路径（Augment Path），首先介绍一下什么是增广路径。
        1. 增广路径
            -- 设 M 是二分图 G=(V,E) 的一个匹配边集
            -- 若P是图G中一条连通两个未匹配顶点的路径，并且属于M的边和不属于M的边(即已匹配和待匹配的边)
            -- 在P上交替出现，则称P为相对于M的一条增广路径（举例来说，有A、B集合，增广路由A中一个点通向B中一个点，再由B中这个点通向A中一个点……交替进行）。
                    
        2. 增广路径具有以下三个重要性质：
            -- P的路径长度必定为奇数，第一条边和最后一条边都不属于M
            -- 不断寻找增广路可以得到一个更大的匹配M’，直到找不到更多的增广路
            -- M为G的最大匹配当且仅当不存在M的增广路径
            -- 最大匹配数M+最大独立数N=总的结点数
            -- 最大匹配数M+最大独立数N=总的结点数
            -- 如果对增广路径进行“取反”操作，新的匹配数就比已知匹配数增加一个，也就是说，可以得到一个更大的匹配。
                >> 所谓的取反操作，就是把增广路径上奇数编号的边加入到已知匹配中，并把增广路径上偶数编号的边从已知匹配中删除。
                >> 每做一次“取反”操作，得到的匹配就比原匹配多一个
                >> 为啥多一个呢？因为增广路径有奇数条边，在匹配 M 中的边比不在 M 中的边少 1 个（理解第一条特性），取反以后，自然就变成多 1 个了。
                
​       3. 顶点开始搜索增广路径的流程如下：

            while(从 Xi 的邻接表中找到下一个关联顶点 Yj)
            {
                if(顶点 Yj 不在增广路径上)
                {
                    将 Yj 加入增广路径;
                    if(Yj 是未覆盖点 或者 从与 Yj 相关连的顶点（Xk）能找到增广路径)
                    {
                        将 Yj 的关联顶点修改为 Xi；
                        从顶点 Xi 开始有增广路径，返回 true；
                    }
                }
                从顶点 Xi 开始没有增广路径，返回 false；
            }

        4. 数据模型
            -- 用邻接矩阵存储图，用从 0 开始的数字为每个顶点编号。
                >> edge[2][4]=1 表示X集合的2号顶点和Y集合的4号顶点之间有条边。
            -- 边的信息模型
                >> path[1]=5，表示当前匹配边集上有一条边，它的一个顶点编号是1，另一个顶点的编号是5
            -- 数据结构
                typedef struct 
                {
                    int edge[UNIT_COUNT][UNIT_COUNT];
                    bool on_path[UNIT_COUNT];   // 标识顶点是否已经在增广路径上
                    int path[UNIT_COUNT];   
                    int max_match;
                }GRAPH_MATCH;

        5. 算法实现
            -- 匈牙利算法的思路就是不停地寻找增广路径，增加匹配的个数，当不能再找到增广路径时，算法就结束了，得到的一个匹配就是最大匹配。
            -- 因此，我们先实现寻找增广路径的函数，寻找增广路径可以从 X 集合的点开始，也可以从 Y 集合的点开始。
                如果从X集合的点开始，GRAPH_MATCH数据结构中的path和on_path数组的下标就是 Y 集合的顶点编号。
            -- 查找增广路径
                bool FindAugmentPath(GRAPH_MATCH *match, int xi)
                {
                    for (int yj = 0; yj < UNIT_COUNT; yj++) // 遍历y集上的点
                    {
                        if ((match->edge[xi][yj] == 1) && !match->on_path[yj]) // 判断图中有边，并且不在增广路径上
                        {
                            match->on_path[yj] = true;
                            if ((match->path[yj] == -1) // y没有匹配，继续查找
                                || FindAugmentPath(match, match->path[yj])) // y已经有匹配match->path[yj]，则尝试为match->path[yj]寻找更优匹配深度优先遍历
                            {
                                match->path[yj] = xi;   // 记录了最大匹配的边集
                                return true;
                            }
                        }
                    }
                    return false;
                }

                void ClearOnPathSign(GRAPH_MATCH *match)
                {
                    for (int i = 0; i < UNIT_COUNT; i++)
                    {
                        match->on_path[i] = false;
                    }
                }

                bool Hungary_Match(GRAPH_MATCH *match)
                {
                    for (int xi = 0; xi < UNIT_COUNT; xi++)
                    {
                        if (FindAugmentPath(match, xi))
                        {
                            match->max_match++; //找到的最大匹配数
                        }

                        ClearOnPathSign(match); //清除上次搜索增广路径时记录的标志信息
                    }
                    return (match->max_match == UNIT_COUNT); // True -> 当前找到的最大匹配是个完美匹配
                }

G. 总结
    a. 图论中的很多算法都有公认的最优算法实现，比如本课介绍的求最大匹配的匈牙利算法，再比如带权二分图最大权匹配（最小权匹配）的 Kuhn-Munkres 算法（KM 算法），还有求稳定匹配的 Gale-Shapley 算法等。
    b. 这些都是已知问题的高效算法，也没啥好发挥的，玩算法的人基本上都要准备好这些算法的实现模板，只要识别出题目适合用这些算法，直接套模板，算法框架就出来了。
    c. 尽管网上有很多此类算法的实现，但我还是建议大家自己抽空把这些算法写一遍，研究透原理和实现。
    d. 原因很简单，套模板的时候，少不了要修改数据模型，以便适应题目要求，如果不熟悉算法实现，难免会改错，耽误时间。