动态规划法
=======================================================================================
A. 原理：
    1. 把多阶段决策过程转化为一系列的单阶段决策问题，利用各个阶段之间的递推关系，逐个确定每个阶段的最优化决策，最终堆叠出多阶段决策的最优化决策结果。
    2. 对所有子问题求解的内在机制是一种广域搜索
    3. 如何识别一个问题是: 多阶段决策问题？
B. 使用条件：
    1. 满足最优化原理：不管之前的决策是否是最优决策，必须保证从现在开始的决策是在之前决策基础上的最优决策 -- 【最优子结构的性质】
    2. 子问题的无后向性： 【定义子问题，安排子问题的求解顺序是关键点】
        a. 当各个阶段的子问题确定以后，对于某个特定阶段的子问题来说，它之前各个阶段的子问题的决策只影响该阶段的决策，对该阶段之后的决策不产生影响。
C. 决策的主线：
    1. 随时间划分    ---  有相关的例子吗？
    2. 随着问题的演化状态来划分  --- 最长公共子序列问题/0-1背包问题
D. 四个步骤： --- 【需要根据已知信息调节步骤的顺序】

    1. 定义最优子问题（最优解的子结构）
        a. 确定问题的优化目标
        b. 确定最优解的决策
        c. 对决策过程划分阶段     【阶段： 一个问题从开始到解决需要经过的环节】
            -> 按照时间或动作的顺序划分阶段 (装配线与工作站问题)
            -> 组合状态划分阶段 (凸多边形三角剖分问题)

        d. 最优解: 按照阶段顺序依次选择的一个决策序列。

    2. 定义状态 【最优解的值-无向后性陷阱】
        a. 状态既是决策的对象，也是决策的结果
        b. 状态的定义是建立在子问题定义基础之上的，因此状态必须满足无后向性要求。必要时，可以增加状态的维度，引入更多的约束条件，使得状态定义满足无后向性要求。

    3. 定义决策和状态转换方程 【定义计算最优解的值的方法/等式】
        a. 决策就是能使状态发生转变的选择动作，如果选择动作有多个，则决策就是取其中能使得阶段结果最优的那一个。
        b. 状态转换取决于子问题的堆叠方式
            -> 状态定义得不合适，会导致子问题之间没有重叠, 也就不存在状态转换关系  --- 【如何理解子问题间的重叠？】
            -> 没有状态转换关系，动态规划也就没有意义，退化为像分治法那样的朴素递归搜索算法了。

    4. 确定边界条件
        a. 对于递归加备忘录方式（记忆搜索）实现的动态规划方法，边界条件实际上就是递归终结条件。
        b. 对于使用递推关系直接实现的动态规划方法，需要确定状态转换方程的递推式的初始条件或边界条件，否则无法开始递推计算。

E. 区别：
    1. 分治法的子问题之间是相互独立的
    2. 动态规划的子问题之间存在堆叠关系 ---【递推关系式确定的递推关系】 -- 【很重要】

F. 分类：
    1. 线性模型
    2. 串模型（字符或数字）
    3. 区间模型
    4. 状态压缩模型
    5. 等等


穷举搜索法
==========================================================================================================================================
A. 概述：
    1. 穷举法是一种在问题域的解空间中对所有可能的解穷举搜索，并根据条件选择最优解的方法的总称。

B. 难点：
    1. 解空间或状态空间的定义没有具体的模式，不同问题的解空间形式上也差异巨大；
    2. 针对不同问题要选择不同的搜索算法，有很多问题的搜索算法并不直观，需要对问题做细致的分析并且依靠丰富的经验才能设计出来。
    3. 穷举法被公认为是最“难用”的算法模式。

C. 步骤：
    1. 确定问题的解（或状态）的定义、解空间的范围以及正确解的判定条件
        a. 简单解空间 -- 根据问题可以设计整个解空间
        b. 复杂解空间 -- 根据候选解或状态的转换关系动态生成解空间
            -> 【解空间-状态树】 由一个原始状态开始，逐步扩展至整个解空间。   
            -> 【节点和边的关系空间】 用图的一些方法组织和搜索解空间 
        c. 简化技巧
            -> 若存在状态转换关系 - 将对问题的解的穷举遍历变成对这个状态空间的的穷举遍历。

    2. 根据解空间的特点来选择搜索策略，逐个检验解空间中的候选解是否正确
        a. 搜索算法
            -> 线性搜索算法用于对线性解空间的搜索    【线性表、集合】
            -> 广度优先和深度优先的递归搜索算法适用于树型解空间或更复杂的图型解空间。  【树或者图】

        b. 搜索策略
            -> 没有捷径, 多实践，多积累。
            -> 剪枝策略
                - 难点: 如何找到一个评价方法（估值函数）
                - 特定问题类型的剪枝算法之外，没有的通用方法，具体问题具体分析

            -> 限制搜索深度的方法加快算法的收敛(限制搜索深度会导致无解，或错过最优解)
            -> 盲目搜索
                - 广度优先搜索 【额外空间】
                - 深度优先搜索 【死循环】
            -> 启发式搜索
                - 若解空间的状态分布呈现正态分布的特征，则可以从分布中间值开始向两边搜索 
                - A* 寻径算法

    3. 搜索算法的评估和收敛
        a. 问题规模大到一定程度时，使用穷举法就只具有理论上的可行性。
        b. 收敛原则是只要能找到一个比较好的解就返回（不求最好），根据解的评估判断是否需要继续下一次搜索。
            -> 大型棋类游戏 - 搜索整个解空间得到最优解目前是不可能的 - 搜索深度参数来控制搜索算法的收敛。

D. 其他
    1. n元组的遍历有递归、多重循环等多种成熟的实现方法可以选择，简单套用即可。



