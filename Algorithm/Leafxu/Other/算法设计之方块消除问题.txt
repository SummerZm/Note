方块消除
======================================================
A. 名词印象
    a. 串模型的动态规划
    b. 区间动态规划模型
    c. 状态压缩动态规划模型
    d. 线性动态规划模型
    e. 我们用的算法实现都是尽量使用状态递推关系式直接用递推的方法

B.  主题
    a. “备忘录（或状态记忆）”也是动态规划

C. 问题分析
    a. 子问题和最优子结构的状态定义
        1. 这个问题的关键是让后面的方块或区域能和前面的同色方块或区域连成连续的区域
            -- 最优子结构的构成就是“前面”和“后面”两部分
            -- 状态定义不针对某个阶段，而是针对这个问题之前的最优决策定义状态，然后结合后面的部分做当前问题的最优选择
            -- 这样做的好处是在很多情况下分解的子问题天然具有无后向性
            -- 例子: 投资问题/方块消除

        2. 状态和状态递推关系
            --  信息数字化处理
                >> 对颜色编号，给不同的颜色分配不同的数字编号，将计算机无法直接处理的颜色方块序列变成了 1 2 2 2 2 3 3 3 1 
                >> 每个区域用 color 属性表示颜色编号，用 len 属性表示区域长度，可得 {1,1}、{2,4}、{3,3}、{1,1}
                >> color = {0,1,2,3,1}; len = {0,1,4,3,1}

            --  子问题状态定义 d[i,j,k]
                >> 表示区域 i 和区域 j−1 之间的颜色区域和经过一系列消除动作后，color[j] 与后续的 k 个和 color[j] 相同颜色方块连成的新区域color[j],len[j]+k 共同消除后的最高得分。
                >> k 的意义在于根据前面区域 i 和区域 j−1 之间的颜色区域消除动作的选择不同，k 的值也有相应的变化。
                >> 这里状态描述里的“前面”就是区域 i 和区域 j−1 之间的颜色区域，“后面”就是 color[j] 与后续的k个和 color[j] 相同颜色方块连成的新区域 color[j],
                len[j]+k、d[i][j][k] 的决策就有两个选择。

（1）将区域 

color[j],len[j]+k 消除，状态转移方程就是：

d[i,j,k]=d[i][j−1][0]+(len[j]+k)2
（2）暂时不消除区域 

color[j],len[j]+k，而是将其连接到前面的某个颜色相同的区域上，形成更大的区域。注意这里并不是立即连接，而是不消除这块区域，等着其他消除动作完成后，让这块区域和前面那个区域之间的方块都消完后再连接成连续区域。这个“等其他消除动作完成”是通过递推关系实现的，就是等其他子问题求解完成。理解这一点很重要，我当初就是颇费周折才想通这一点的。假设前面那个颜色相同的区域是 

p(i≤p<j)，则状态转移方程就是：

d[i,j,k]=d[i,p,len[j]+k]+d[p+1,j−1,0]
因为区域 

color[j],len[j]+k 连接到前面的 p 区域上了，所以区域 p + 1 和 j−1 之后就没有相同颜色的区域了，因此对应状态的 k 就是 0 了。

显然，我们要的是这两个选择中的最大值作为最后的得分，那么此问题的状态转移递推关系式就是：

enter image description here

初始状态和结果

对于任何一个颜色区域 i，如果前面没有颜色方块可消除，则其得分是 0，这就是初始值，即 d[i,i−1,0]=0，
最后的结果就是全部颜色区域的消除得分，自然就是 d[1,m,0] 了，它表示的是包括第一个颜色区域和最后一个颜色区域的完整问题的状态。

算法实现

前面说了，我们要用备忘录（或状态记忆）方法实现这个动态规划算法。
返回看看刚分析的“状态递推关系”就知道了，这里面有递归，用递归方法实现状态的递推计算是很自然的选择了。
根据递推关系式，这个递归函数的参数实际也定了，就是 i、j 和 k，不妨这样定义这个递归函数：

int dp(int i, int j, int k)
在算法开始之前，需要将原始输入的数据做个处理，即按照颜色分成颜色区域块，dp() 函数假设这个处理已经完成了，即 color 数组和 len 数组已经整理好了。
dp() 函数的退出条件就是 i 和 j 相同的时候，此时直接计算区域 i 的得分就是状态 d[i,j,k] 的得分。

dp() 函数的递归子结构主体首先要判断当前状态 

d[i,j,k] 是否已经被求解过，如果已经被求解过，则直接返回状态值 

d[i,j,k]。判断子问题状态是否被求解过的方法就是看其值是否大于 0，当然，为了配合这个判断，在算法开始之前需要将所有的子问题状态值都初始化为 0。

dp() 函数的递归子结构主体接下来是按照递推关系式求解 

d[i,j,k] 的值，求解分两步，第一步先用第一种方法求解一个值，然后再用第二种方法继续求解，并根据从中选择最大的值作为 

d[i,j,k] 最终的结果。如果之前的问题分析都看懂了，这个函数其实也没啥好说的了，看代码吧。

int dp(int i, int j, int k)
{ 
    if (i == j)
    {
        d[i][j][k] = (len[j] + k)*(len[j] + k);
        return d[i][j][k];
    }

    //备忘录状态查询
    if (d[i][j][k] > 0)
    {
        return d[i][j][k];
    }

    //暂时先取第一种方式的结果作为 d[i][j][len] 的值
    d[i][j][k] = dp(i, j - 1, 0) + (len[j] + k) * (len[j] + k);`

    //按照第二种方式计算，并根据情况更新 d[i][j][len] 的值
    for (int p = i; p < j; p++)
    {
        if (color[p] == color[j])
        {
            int tmp = dp(i, p, len[j] + k) + dp(p + 1, j - 1, 0);
            if (tmp > d[i][j][k])
            {
                d[i][j][k] = tmp;
            }
        }
    }

    return d[i][j][k]; 
}

//在准备好 color 数组和 len 数组得情况下求解内容中给出的例子
int score = dp(1,4,0); //29
总结

说实话，按照我的理解，这个题目用动态规划方法有点“为赋新词强说愁”的感觉，状态定义十分的难以用语言表达，如果读者能理解这个状态定义，估计以后再复杂的状态定义也不在话下了。另外，即使用了动态规划方法，整个算法的时间复杂度仍然是 
O(n4) 级别的。

但是作为一个动态规划的典型问题，对这个问题的理解能极大地提高对动态规划方法的理解。