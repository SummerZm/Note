投资问题
=======================================================
A. 动态规划理论最早被提出来的时候，是用来解决资源的有效分配问题。
    -- 总资源量有限，要分配给若干个项目，每个项目都有一个投入与收益的关系，最终的问题是求如何规划在不同项目上的投资，使得收益能够最大化。

B. 问题分析
    a. 定义状态
        1. d[i,j]d[i,j] 为给前 i 个项目投入 j 万元时能获得的最大收益。 -- 满足无后向性
        2. d[i,j]d[i,j] 就表示项目 i 投入 j 万元获取的最大收益。 --  不满足无后向性

    b. 递推关系
        1. 给前 i 个项目投入 j 万元能获取的最大收益包含两部分，一部分是给第 i 个项目投入 k 万元获得的收入，另一部分是给前 i−1 个项目投入 j−k 万元获得的收入。
        2. 不包含第 i 个项目的前 i−1 个项目投入 j−k 万元获得的收益
        3. 第 i 个项目投多少才能使得 d[i,j] 获得最大值呢?
            -- 无法决策，按照惯例，那就枚举一遍 [递推关系]
            -- 在堆叠计算状态的时候，需要对某个关系做遍历（穷举）【很典型的递推关系公式】

    c. 实现算法
        1. 决策阶段的循环: 第一层循环是项目 i 的循环（前 i 个项目的意思）
        2. 投资额度的循环: 第二层循环是给前 i 个项目投 j 万元；
        3. 穷举遍历循环： 第三层循环是如何将 j 分给当前项目 i 和前 i−1 个项目的一个


            // n 个项目，投资 m 百万元 
            int investment(int n, int m, int d[][MAX_M], int max[][MAX_M])
            {
                //初始化（也就是只有一个项目的情况）
                for (int x = 0; x <= m; x++)
                {
                    d[0][x] = f[0][x];  // 投资第一个项目  -- f[0][x]输入数据[用二维数组存放提供收益函数表]
                    max[0][x] = x; //标记函数初始化
                }
                
                for(int i = 1; i < n; i++) // 投资前 i 个项目 
                { 
                    for(int j = 0; j <= m; j++) // 前 i 个项目总投入的钱数 j 
                    { 
                        for(int k = 0; k <= j; k++) // 投资当前项目的钱数（第 i 个项目）
                        { 
                            // 遍历在之前的基础上解决子问题
                            int tmp = f[i][k] + d[i - 1][j-k]; 
                            if(tmp > d[i][j]) //d[i][j] 初始化都是 0
                            { 
                                d[i][j] = tmp; // 更新当前的最优解 -- 总收益
                                max[i][j] = k; // 更新标记函数 -- 当前项目的最佳投资
                            } 
                        } 
                    } 
                } 

                return d[n - 1][m];
            }

        4. 结果输出 【如何打印决策过程】
            -- 所有动态规划算法实现都存在一个问题，就是结果输出不直观的问题 【决策过程隐藏在递推关系计算过程中】
            -- 在递推计算的过程中保存决策点的决策信息
            -- 计算完成后根据最后一个最优解对应的决策点信息反推这个最优解之前的每一步决策过程
            -- 非递归式打印实现: 

            // n个项目投资m元
            void print_result(int n, int m, int max[][MAX_M])
            {
                int invesment[MAX_N] = { 0 };
                
                invesment[n - 1] = max[n - 1][m];  // 第n个阶段的最优解结果
                for (int i = n - 2; i >= 0; --i)   
                {
                    int t = 0;
                    for (int j = n - 1; j > i; --j) // 计算出 n-1 到 i 用了多少投资 【便于在max数据中找到m-t投资时的最优方案】
                    {
                        t += invesment[j];
                    }
                    invesment[i] = max[i][m - t];    // 第i个阶段的最优解结果 
                }

                for (int x = 0; x < n; x++)
                {
                    printf("Invest %d for project %d\n", invesment[x], x + 1);
                }
            }

        5. 总结
            -- 区间动态规划枚举遍历的是区间的分割点
            -- 这个问题枚举的是当前给第 i 个项目投入的资金数
            -- 两者的递推关系式中都有在若干个不同的状态递推结果中求最大值的要求，这就需要对这些递推结果遍历一下，求最大值。