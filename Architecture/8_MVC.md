## **MVC 理解**

### **一、MVV的类型和演变**
#### **A. 胖Model型**
- Model层：包含大部分业务核心逻辑；缺点：复用性差；改进：ViewModel层格式化输出数据
- View层：界面显示
- Controller层：

#### **B. 胖Controller型**
- Model层： 数据库接口
- View层：界面显示
- Controller层：包含大半部分业务核心逻辑；监听事件/IO请求数据/格式化数据；改进：ViewModel层格式化输出数据

### **二、架构上的考虑**
> **Model 层在最底层；View 层在中间，它持有 Model 层的 DOM 指针；Controller 层在最上方**
#### Model层（数据层+业务逻辑） = service（业务逻辑处理）+repository（DAO数据访问）+model（贫血模型）
- Model 层的使用接口最重要的是要自然体现业务的需求。只有这样，Model 层的边界才是稳定的。
- Model 层要为 View 层提供一些专享的只读访问接口。Model层类似于DOM，而View层则是其可视镜像。
- Model 层作为架构的最底层，它不需要知道其他层的存在，不需要知道到底是 MVC 还是 MVP，或者是其他的架构范式。

#### View层 = 图形界面
- 关于于图形界面的跨平台使用
    ```sh
    # 响应用户交互事件的入口，这是操作系统的界面编程框架决定的。
    # 比较理想的情况下，View 应该把自己所有的事件都委托（delegate）出去，不要自己干。
    ```
- View 层不一定会负责生成所有用户看到的 View。
- View 层可能需要非常友好的委托（delegate）机制的支持。例如，支持一组界面元素的交互事件共同做委托。
- View 层负责界面呈现，看似只是根据数据绘制界面，似乎很简单，但实则不简单。原因在于：为了效率，我们往往需要做局部更新的优化。
    ```sh
    # 局部更新这个优化足够复杂时，我们往往不得不在 Model 和 View 之间，再额外引入一层 ViewModel 层来做这个事情
    # 例1: Word。它是数据流式的文档，但是界面显示人们用得最多的却是页面视图，内容是分页显示的。
    #      这种情况下就需要有一个 ViewModel 层是按分页显示的结构来组织数据。
    #      其中负责维持 Model 与 ViewModel 层的数据一致性的模块，我们叫排版引擎。
    ```
#### Controller = 用户功能/操作
- Controller 之间应该是完全无关的，功能内聚，聚焦用户的一组操作，模块化移除简单。
- 通过 DOM 接口操作 Model 层，但它并不操作 View 去改变数据，而只是监听自己感兴趣的事件。
- 可能包含一些属于自己的辅助 View(如：菜单栏)，接受 View 层委托的一些事件，由事件驱动自己状态，最终通过调用 Model 层的使用接口来完成一项业务。
    ```sh
    # 例2: Controller 模块的辅助 View 可能是持续可见的，比如菜单和工具条；也可能是一些临时性的，比如 Office 软件中旋转图形的控制点。
    # 对于后者，如果存在 ViewModel 层的话，也有可能会被归到 ViewModel + View 来解决.
    # 因为 ViewModel 层可以有 Selection 这样的东西来表示View 里面被选中的对象。
    ```

