## **操作系统内核与编程接口**

### **实地址模式**
- **同一个物理地址空间下，操作系统如何分配内存？**
    1. **把操作系统内存管理相关的函数地址，放到一个大家公认的地方**，每个软件要想申请内存就到这个地方取得内存管理函数并调用它。
    2. **把内存管理功能设计为一个中断请求** 所谓中断，是 CPU 响应硬件设备事件的一个机制。当某个输入输出设备发生了一件需要 CPU 来处理的事情，它就会触发一个中断。

### **保护模式**
- **在保护模式下，计算机的基础架构体系和操作系统共同在努力做的一件事情，就是让每个软件“感觉”自己在独占整个计算机的资源**

### **操作系统与软件的通信**
- **系统调用是怎么工作的？**
    1. 操作系统的能力通过软中断向我们写的软件开放，为此还专门引入了一个术语叫 “系统调用（syscall）”。
    2. 从虚拟内存机制的视角，操作系统内核和所有进程都在同一个地址空间，也就是，操作系统内核，它是所有进程共享的内存
    3. 操作系统内核的代码和数据，不只为所有进程所共享，而且在所有进程中拥有相同的地址。这样无论哪个进程请求过来，对内核来说看起来都是一次本进程内的请求
    4. 从单个进程的视角，中断向量表的地址，以及操作系统内核的地址空间是一个契约。有了中断向量表的地址约定，用户态函数就可以发起一次系统调用（软中断）

- **编程语言接口**
    1. 最原始的调用方式，是用软中断指令。 
    2. 操作系统（内核）有六大子系统：存储管理、输入设备管理、输出设备管理、进程管理、网络管理、安全管理。
    3. 大部分高级语言都实现了操作系统编程接口的封装。【对一些系统调用的封装】
    
- **动态库**
    1. **问题：从操作系统的角度来说，它仅仅提供最原始的系统调用是不够的，有很多业务逻辑的封装，在用户态来做更合适。它也无法去穷举所有的编程语言，然后一一为它们开发各种语言的基础库**
    2. **解决：动态库本质上是实现了一个语言无关的代码复用机制。它是二进制级别的复用，而不是代码级别的。这很有用，大大降低了编程语言标准库的工作量**
        ```sh
        # 1. 浮动地址：动态库本质上是在一个进程地址空间中动态加载程序片段，这个程序片段的地址显然在编译阶段是没法确定的,需要在加载动态库的过程把浮动地址固定下来。
        # 2. 导出函数表：动态库需要记录有哪些函数被导出（export），这样用户就可以通过函数的名字来取得对应的函数地址。
        # 3. 动态库：编程语言的设计者实现其标准库来说就多了一个选择：直接调用动态库的函数并进行适度的语义包装。大部分语言会选择这条路，而不是直接用系统调用。
        ```
        
### **操作系统与编程语言**
- **第一个问题：先有编程语言，还是先有操作系统？** 现有编程语言
- **第二个问题：编程语言怎么做到自举的？**
    ```sh
    # 从鸡生蛋的角度，编译器的进化史应该是这样的：
    #  A. 先用机器码直接写第一个汇编语言的编译器
    #  B. 然后汇编语言编译器编出第一个 C 语言编译器。
    #  C. 有了C 语言编译器后，可以反过来用 C 语言重写汇编语言编译器和 C 语言编译器，做更多的功能增强。
    
    # 这个过程理论上每出现一种新 CPU 指令集、新操作系统，就需要重新来一遍。但是人是聪明的。所以交叉编译这样的东西产生了。
    # 所谓交叉编译就是在一种 “CPU + 操作系统” 架构下，生成另一种 “CPU + 操作系统” 架构下的软件。
    # 这就避免了需要把整个编译器进化史重新演绎一遍。
    ```
 
- **第三个问题：操作系统能够做到自身迭代本操作系统（自举）么？**
    ```sh
    # 通常一门新的操作系统开发之初，会用上面提到的交叉编译技术先干出来
    # 然后等到新操作系统稳定到一定程度后再实现自举
    # 也就是用本操作系统自己来做操作系统的后续迭代开发。
    ```












































