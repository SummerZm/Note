## **关于编程代码中锁的思考**

### **A. 自旋锁**  
- **简介**： <i>听上去很高大上，实际上就是一个死循环</i>
    ```C 
    /*  特点：不让出CPU资源，避免上下文切换, 死等。*/
    while (抢锁(lock) == 没抢到) {
    }
    ```
- **其他**：
    ```sh
    # 现代操作系统在实现自旋锁、互斥锁时，一般都会做优化，比如可能会让互斥锁先自旋一小会儿,可能会在自旋锁自旋超过一定时间后强制切换上下文
    # 可能会在单核非抢占式上让自旋锁什么都不干。这些「优化」我们编程时通常都不需要了解，按照经典实现去理解就足够了。
    ```
    
### **B. 原子对象**
- 原子对象（atomic object）: 一个可通过原子操作被读取或修改的对象
- 原子操作（atomic operation）: 不能被并行线程中断,不引发线程之间的竞态操作
- 原子对象的初始化不是原子操作
- 使用原子对象可以获得更好的性能。一般比互斥锁快

### **C. 互斥锁**
- **简介**: <i>独占某一代码区的执行权(访问/修改)</i>
    ```C
    /* 特点：让出CPU资源，发生上下文切换，大约10倍于原来的时间。
       线程是操作系统调度的，互斥量需要交给操作系统维护，这导致了上下文切换，耗性能。
       有些实现可以使用： 用户空间futex API，减少上下文切换, 系统调用次数。
    */
    while (抢锁(lock) == 没抢到) {
        //本线程先去睡了请在这把锁的状态发生改变时再唤醒(lock);
    }
    ```

- **互斥锁原理-问题-理解**
    1. **<i>互斥锁是通过标志内存页可读写执行标志位实现的吗？</i>**
 
### **D. 条件变量**
- **简介**： <i>我们不是任何时候都想独占某一代码区的执行权(访问/修改)</i>
    ```C
    // 这是「生产者消费者问题」中的消费者的部分逻辑
    // 等待队列非空，再从队列中取走元素进行处理
    加锁(lock);  // lock 保护对 queue 的操作
    while (queue.isEmpty()) {  // 队列为空时等待
        解锁(lock);
        // 这里让出锁，让生产者有机会往 queue 里安放数据
        加锁(lock)
    }
    data = queue.pop();  // 至此肯定非空，所以能对资源进行操作
    解锁(lock);
    消费(data);  // 在临界区外做其它处理

    /* 
      条件没有发生改变，while里就没有必要再去加锁、判断、条件不成立、解锁，完全可以让出CPU给别的线程
      改进之后的版本: 
    */
    // 唤醒,惊群
    while (queue.isEmpty()) { 
        解锁后等待通知唤醒再加锁(用来收发通知的东西, lock);
    }
    ```

### **E. 读写锁**
- **简介**：<i>更细致的锁，更灵活的贴合具体使用场景</i>
    ```C
    /*
     * 读写竞争时没能按先请求先获得的顺序分配，读写竞争频繁时，读请求会一直加锁，写请求会持续得不到满足，陷入饥渴.
     * 解决方案：等待队列，唤醒队列.
     */
    void 读者加锁(rwlock) {
        lock(rwlock.保护当前读者数量的锁);
        rwlock.当前读者数量 += 1;
        if (rwlock.当前读者数量 == 1) {
            lock(rwlock.保护写操作的锁);
        }
        unlock(rwlock.保护当前读者数量的锁);
    }

    void 读者解锁(rwlock) {
        lock(rwlock.保护当前读者数量的锁);
        if (rwlock.当前读者数量 == 0) {
            unlock.(rwlock.保护写操作的锁)
        }
        unlock(rwlock.保护当前读者数量的锁);
    }

    void 写者加锁(rwlock) {
        lock(rwlock.保护写操作的锁);
    }

    void 写者解锁(rwlock) {
        unlock(rwlock.保护写操作的锁);
    }
    ```

- **细节问题**
1. <i>使用while而不是if来做判断状态是否满足？</i>
    ```sh
    # 避免惊群；
    # 避免某些情况下线程被虚假唤醒（即没有pthread_cond_signal就解除了阻塞）。
    ```
2. 
3. 


### **X. 总结思考**
1. **自旋锁、互斥量不是对资源进行上锁，而是对操作进行上锁/解锁，实现互斥独占的需求。如果有新一代码片段没有上锁/解锁，则且旧的已有代码将会失效，引发雪崩。**
2. **C++ 在构造/析构函数上锁/解锁，确保漏调情况。**

### **Z. 参考链接**
[如何理解互斥锁、条件锁、读写锁以及自旋锁？](!https://www.zhihu.com/question/66733477)