volatile
----------------------------------------------------------------------------------------------
volatile是一个类型修饰符(type specifier)
volatile修饰的变量可能会被意想不到地改变，确保本条指令不会因编译器的优化而省略，且要求每次直接读值。
volatile应该解释为“直接存取原始内存地址”比较合适，“易变的”这种解释简直有点误导人；

  比如如下程序：
	XBYTE[2]=0x55;
	XBYTE[2]=0x56;
	XBYTE[2]=0x57;
	XBYTE[2]=0x58;
  对外部硬件而言，上述四条语句分别表示不同的操作，会产生四种不同的动作.
  编译器却会对上述四条语句进行优化，忽略前三条语句，只产生一条机器代码 -- XBYTE[2]=0x58.
  键入volatile，则编译器会逐一地进行编译并产生相应的机器代码, 产生四条代码.

编译器在用到这个变量时必须每次都小心地重新读取这个变量的值，而不是使用保存在寄存器里的备份.
  volatile变量的例子：
    A. 并行设备的硬件寄存器（如：状态寄存器）
    B. 一个中断服务子程序中会访问到的非自动变量（Non-automatic variables)
    C. 多线程应用中被几个任务共享的变量
嵌入式系统程序员经常同硬件、中断、RTOS等等打交道，所有这些都要求使用volatile变量。不懂得volatile内容将会带来灾难。

--------------------------------------------------------------------------------------------------------
假设被面试者正确地回答了这个问题（嗯，怀疑是否会是这样），我将稍微深究一下，看一下这家伙是不是真正懂得volatile完全的重要性。
	A. 一个参数既可以是const还可以是volatile吗？解释为什么。
	B. 一个指针可以是volatile 吗？解释为什么。
	C. 下面的函数被用来计算某个整数的平方，它能实现预期设计目标吗？如果不能，试回答存在什么问题：
		int square(volatile int *ptr)
		{
			return ((*ptr) * (*ptr));
		}

	答案：
	1. 是的。一个例子是只读的状态寄存器。它是volatile因为它可能被意想不到地改变。它是const因为程序不应该试图去修改它。
	2. 尽管这并不很常见。一个例子是当一个中断服务子程序修改一个指向一个buffer的指针时。
	3. 这段代码是个恶作剧。这段代码的目的是用来返指针*ptr指向值的平方.
	   由于*ptr指向一个volatile型参数，编译器将产生类似下面的代码：
			int square(volatile int* ptr) 
			{
				int a,b;
				a = *ptr;
				b = *ptr;
				return a*b;
			}
		由于*ptr的值可能在两次取值语句之间发生改变，因此a和b可能是不同的。
		结果，这段代码可能返回的不是你所期望的平方值！正确的代码如下：
			int square(volatile int*ptr)
			{
				int a;
				a = *ptr;
				return a*a;
			}
			a. 编译器的优化（请高手帮我看看下面的理解）
			在本次线程内，当读取一个变量时，为提高存取速度，编译器优化时有时会先把变量读取到一个寄存器中；
			以后再取变量值时，就直接从寄存器中取值；
			当变量值在本线程里改变时，会同时把变量的新值copy到该寄存器中，以便保持一致
			当变量在因别的线程等而改变了值，该寄存器的值不会相应改变，从而造成应用程序读取的值和实际的变量值不一致
			当该寄存器在因别的线程等而改变了值，原变量的值不会改变，从而造成应用程序读取的值和实际的变量值不一致

	4. 在vc6中，一般调试模式没有进行代码优化，所以这个关键字的作用看不出来。
	   下面通过插入汇编代码，测试有无volatile关键字，对程序最终代码的影响：

			#include<stdio.h>
			void main(int argc,char *argv[])
			{
				int i = 10;
				int a = i;
				printf("i=%d",a);

				//下面汇编语句的作用就是改变内存中i的值，但是又不让编译器知道
				 __asm
				 {
					mov dword ptr[ebp-4],20h
				 }
				 int b = i;
				 printf("i=%d",b);
			}

			然后，在调试版本模式运行程序，输出结果如下：
			 i = 10
			 i = 32
			然后，在release版本模式运行程序，输出结果如下：
			 i = 10
			 i = 10

		输出的结果明显表明，release模式下，编译器对代码进行了优化，第二次没有输出正确的i值。
		下面，我们把 i的声明加上volatile关键字，看看有什么变化：
			#include<stdio.h>
			void main(int argc,char *argv[])
			{
				volatile int i = 10;
				int a = i;
			    printf("i=%d",a);
				__asm
				{
					mov dword ptr[ebp-4],20h
				}
				int b = i;
				printf("i=%d",b);
			}

			分别在调试版本和release版本运行程序，输出都是：
			 i = 10
			 i = 32
		这说明这个关键字发挥了它的作用！

---------------------------------------------------------------------------------------------------------------
编译器优化：
	
	例子1:
	(int i=0; i<100000; i++); 语句用来测试空循环的速度的
	编译器肯定要把它优化掉，根本就不执行

	(volatile int i=0; i<100000; i++); 会执行了volatile的本意是“易变的”

	例子2:
	static int i = 0;
	int main(void)
	{
	    //...
		while(1)
		{
			if(i)
	            dosomething();
		}
	}

	/*Interruptserviceroutine.*/
	void ISR_2(void)
	{
		i=1;
	}
	程序的本意是希望ISR_2中断产生时，在main当中调用dosomething函数，但是，由于编译器判断在main函数里面没有修改过i，
	因此可能只执行一次对从i到某寄存器的读操作，然后每次if判断都只使用这个寄存器里面的“i副本”，导致dosomething永远也不会被调用。
	如果将变量加上volatile修饰，则编译器保证对此变量的读写操作都不会被优化(肯定执行).

	在大多数情况下，把变量缓存在寄存器中是一个非常有价值的优化方法，如果不用的话很可惜。
	C和C++给你提供了显式禁用这种缓存优化的机会。

------------------------------------------------------------------------------------------------------------------
锁的特性和volaite

	A. 锁提供了两种主要特性：互斥（mutual exclusion）和可见性（visibility）。
	  a. 互斥性(时间): 即一次只允许一个线程持有某个特定的锁，因此可使用该特性实现对共享数据的协调访问协议.(原子操作)
	  b. 可见性(空间): 即确保释放锁之前对共享数据做出的更改对于随后获得该锁的另一个线程是可见的 如果没有同步机制提供的这种可见性保证，
	       线程看到的共享变量可能是修改前的值或不一致的值，这将引发许多严重问题.
	  c. 所谓同步机制就是寻求数据在时间和空间上的统一

	B. Volatile 变量
	  a. Volatile变量具有可见性，但是不具备互斥性。
	  b. 单独使用volatile不足以实现计数器、互斥锁或任何具有与多个变量相关的不变式（Invariants）的类（例如 “start <=end”）。
	  c. volatile变量不会像锁那样造成线程阻塞，因此也很少造成可伸缩性问题。
	  d. 读操作远远大于写操作情况下，volatile变量还可以提供优于锁的性能优势。

	C. 有限的一些情形下使用volatile变量替代锁,必须同时满足下面两个条件：
	  a. 对变量的写操作不依赖于当前值。
	  b. 该变量没有包含在具有其他变量的不变式中。
	  
	  第一个条件的限制使 volatile变量不能用作线程安全计数器。
	  增量操作(x++)看上去类似一个单独操作，实际上它是一个由读取－修改－写入操作序列组成的组合操作，必须以原子方式执行.
	  而volatile不能提供必须的原子特性。实现正确的操作需要使 x 的值在操作期间保持不变，而 volatile变量无法实现这点。
	  然而，如果将值调整为只从单个线程写入，那么可以忽略第一个条件

	  不变式错误
	  public class NumberRange{
			private int lower,upper;
			public int getLower(){
		         return lower;
			}
			public int getUpper(){
				return upper;
			}
			public void setLower(int value){
				if(value > upper) throw new IllegalArgumentException(...);
				lower = value;
			}
			public void setUpper(int value){
		         if(value < lower) throw new IllegalArgumentException(...);
				upper = value;
			}
	  }
	 如果初始状态是(0,5)，同一时间内，线程A调用setLower(4)并且线程B调用setUpper(3)，使得最后的范围值是(4,3) —— 一个无效值。
	 至于针对范围的其他操作，我们需要使setLower()和setUpper()操作原子化
	 将字段定义为 volatile 类型是无法实现这一目的的。
																					 
