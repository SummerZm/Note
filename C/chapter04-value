1. 定义与声明的区别
	A. 声明并不是说明自身，而是描述在其他地方已经定义过该标识符
	B. 定义为标志符分配相应类型的内存
	C. 一个标识符只能有一个定义，可以多个声明
	D. 定义：int Num[30]
	   声明: extern Num[] 注：声明可以不表明数组长度, 但为了可读性，我们应该把数组长度也补上

2. 数组与指针的区别
	A. 指针存放着数据的地址，通过*操作符间接访问数据
	B. 数组存放着数据，可以直接符文数据. 
	C. *p+1 与 p[i] 访问的数据一直样，但访问的方式不一样。一个间接，一个直接
	D. 定义指针时，只分配存放地址的内存大小，一般时4个字节
	E. 定义数组时，根据数组类型，长度分配相应的内存
	F. 相关例子：
		a. char* pstr = "ddddd";
			----> OK, "ddddd"是字符常量，编译时放在常量区. 可以修改pstr

		b. int * Num = 12;
			----> error, 指针定义仅分配了存放 "记录数值12所在地址"的内存，没有为数值12分配内存空间

		c. char array[] = "dddddd";
			----> OK， 编译时常量区存放了"dddddd", 运行到此时，将常量区中的"dddddd", 拷贝一份到array数组所在空间中
	

3. 赋值的理解 
	A. = 左边是内存的地址【内存中的地址】; 右边是存入该地址的内容【内存中的数据】
	B. 赋值的本质是：把右边的内容，放到左边的地址空间中
	C. 为什么数组名不能当左值? 
		a. 基础认知: 内存的地址是不能修改
			----> 这是由硬件内存结构，寻址方式决定的。 
			----> 类似的语句是非法的: int Num = 1; &Num = 2; (不能修改内存的地址)  
			----> 无论是数组名，还是&Num, 仅仅只是C语言将硬件内存地址信息,以容易理解，操作的方式呈现给程序员

		b. 数组名，&Num作为硬件信息的呈现, c语言或软件层自然无法修改, 所以编译会报错, 成了口头表述的"不能修改"
			----> 严格来说: 数组名, &Num在硬件本质上是无法被修改的, 所以C语言软件层不能修改，否则会报错 
			----> 除非内存硬件实现内存地址可编辑，编程.

		c. 