 1. C++令人失望的原因
 	A. 对于C语言最基本的语言没有改进
	B. 对于c语言最重要的拓展却建立在脆弱的C类型模型上

 2. C语言存在的一些问题
 	A. 多做之过：
		a. swicth的fallthrough用法，源自于C语言设计的缺陷. 数据统计fallthrough的出现，意味着97% 可能是程序员写漏了break
		b. break 用于跳出最近一层循环. (曾导致美国长途话网瘫痪)
		c. swicth(i)中的i 可在case处理过程中被修改，导致结构混乱
		d. swicth中可以使用goto标签跳转，导致结构混乱
		e. 尽量避免 用块包裹临时变量 的用法 
		f. 字符串自动合并是一个可能导致问题的特性
			eg: 
			char *strArray[] = {
				"green",
				 "red"		// 由于缺少',' 导致red blue被合并
				 "blue",
				 "yellow"
				}

		g. 定义函数时缺省全局可见，即默认extern. 实际上，应该默认不可见更合理
		

	B. 误做之过
		a. 符号过度重用导致难以理解
			eg: ()可以有6种意思
			1. 函数的形参列表
			2. 调用函数
			3. 优先级
			4. 类型转换
			5. 定义带参数的宏
			6. 包围sizeof操作符的操作数（如果这个操作数时操作符）

			eg int i = sizeof(int)*p

			eg: *可以有3种意思
			1. 乘法运算
			2. 声明指针
			3. 在指针中，间接引用

			eg: int i = N * sizeof *p 

		b. 优先级存在的问题
			eg: 容易造成优先级误解的例子. 原因：c语言的优先级存在错误
			1. *p.f
			2. int *pf()
			3. int *pf[]
			4. val & mask !=0
			5. c=getchar != EOF
			6. msb << 4 + lsb
			7. i=1,2
			
			answer:
			1. *(p.f)
			2. int *pf()  是函数，而不是函数指针
			3. int *(pf[]) 是指针数组， 而不是数组指针 int (*ap)[]
			4. val & (mask !=0)
			5. c=(getchar != EOF)
			6. msb <<( 4 + lsb)
			7. (i=1),2


		c. gets()导致的BUG
			1. 代码 char buff[255]; gets(buf);
			2. 当传入的数据大于255时，会造成堆栈溢出
			3. 传入大于255的特制二进制数据，通过堆栈溢出，修改函数过程记录，改变程序流程
			4. 改变程序流程后，调用exec(),启动一个shell替换当前进程，实现入侵
	
	C. 少做之过
		a. shell参数使用 '--xxx' 的由来 (略过)
		b. 空格
			1. 使用旧标准\实现字符串换行时,\后必须跟换行符。不小心在\后加了空格将会导致非常隐秘的BUG
			2. 注释： int i = *n/*y 会报错，因为 /* 是C语言注释的一部分. 为此C++，引入的//注释(但实际引入另一个注释符的问题). 
			3. z = y+++x 如果没有空格很难理解，根据贪婪原则，此表达式应该理解为：z= y++ + z
			   对于 z = y+++++z, 理解为 z = y++ ++ +z, 编译报错。此处语义上应理解为 z= y++ + ++z
			   但空格在C语言中除上述1，2情况会被忽略，所以自相矛盾。

		c. 避免少做malloc/free
			1. 正确的做法：在调用函数前malloc好内存，将指针和内存大小传入函数，函数返回后再free.将malloc和free放在一起，避免少做。




