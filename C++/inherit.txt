A. C++继承
	a. 语法: class [派生类名]: [继承方式] [基类名]
		1. 例子: class student public people
		2. 默认私有继承

	b. 继承方式决定了基类成员在派生类的最高访问权限
	c. 继承的两种应用：
		1. 派生类可以访问子类的非私有成员，并对外提供public成员的访问
		2. 派生类只能内部访问基类的非私有成员，并且对外不开放访问

	d. using 在派生类中使用用于改变从基类继承来public/protected成员的权限
		1. // 基类People
		 class people {
			public:
				void show();
			protected:
				int m_name;
				int m_age;
		 }

		 // 派生类 Student
		 class Student {
			public:

				void learning();
				using People::m_name;  // protected --> public
				using People::m_age;

			private:
				using People::show(); // public --> private
				
		 }

	e, 如何使用基类中的成员	
		1，成员变量: stu.People::m_age;
		2. 成员函数: stu.People::show();

	f. 作用域：
		1. 每个一类是一个作用域。
		2. 继承形成嵌套的作用域
		3. 由于作用域嵌套，子类找不到的成员变量会去找父类的同名变量
		4. 由于作用域嵌套，子类和父类的同名函数不会发生重载，它们严格上不在同一作用域上
	g. 内存布局：成员变量按照派生层次依次排序，新增派生的成员变量排在后面
	h. 构造函数的调用：和形参列表的顺序无关，和类声明的顺序有关
	i. 构造函数/析构函数调用：
		1. 在派生类构造函数的形参列表中调用.【不能在派生类中显示调用基类的构造函数】
			ex1: student(int name, int age, int score): People(name, age), m_scroe(score){}
			ex1: student(nt score): People('haha', 10), m_scroe(score){}
		2. 派生类只能调用直接基类的构造函数
		3. 最好在形参列表指定基类构造函数，否则编译器将使用默认构造函数
		4. 不能被继承，调用顺序相反

B. C++虚继承 [多继承的问题， 虚继承的实现机制 ?]
	a. 问题: 多继承带来的数据冗余和二义性问题. 
		1. 数据冗余 -- 多份基类数据。
		2. 二义性问题 -- 继两个同层次父类具有同样的成员。
		3. [ex: 菱形继承] -- 解决：虚继承: 派生类只保存一份虚基类的成员 
		4. 影响: 使用了虚派生的类进一步派生子类时，新的子类只存有一份虚基类成员

	b. 写法: 
		1. class B: virtual public A
		2. 虚继承需要虚派生类的派生子类形参表中指定显示调用虚基类的构造函数

	c.【虚继承并不能解成员二义性问题】所以应该避免多继承问题

	d, 原理：
		0. 虚继承内存布局由两部分组成：
			固定部分: 普通继承的内存模型 -- 直接使用偏移寻址，性能和C差不多
			共享部分: 虚基类 -- 没有统一的实现，不同编译器实现不同

		1. 实现1: Cfont [编译器给类成员添加指针指向共享部分]
			嵌套得越深，间接范围次越多
			多继承得越多，维护得指针越多

		2. 实现2: VC [虚函数表]
			相对于cfont避开了多级访问
			减少了对象的体积

C. 类的类型转换 [不使用虚函数机制会带来什么问题]
	a. 派生类对象赋值给基类对象 -- 会丢失派生类的新增成员对象 【对象切片，严重的内存泄漏】
	b. 派生类对象指针/引用赋值给基类的指针/引用
		1. 成员变量访问的仍是派生类的 	[隐式类型转换]
		2. 成员函数调用的是基类类的		[成员函数实现的原理: 成员函数是跟着this指针编译时期的类型走的--这时的类型是基类]
		3. 赋值后地址会发生变化，转成不同层次的基类赋值之后的地址不一样
			ex： A -> B -> D
				 c ------> D
			D多继承 B, C; 
				A ra = D;
				B rb = D;
				C rc = D;
			其中，A， B， D地址一样， C则与之不一样

	c. 向上转型之后的对象，指针，引用不能访问派生类新增的成员
	
D. C++的成员函数多态的实现:
	a. 问题: 基类指针指向派生类对象时，只能访问派生类的成员变量，不能访问派生类的成员函数
		1. 解决: 声明虚virtual函数, 定义时可加可不加.
		class teacher: public People {
			public:
				teacher();
				virtual void display(); // 声明时使用虚函数
			private:
				char* name;
				int age;
		}
		2. 好处: 不用为各个派生类声明各种指针，代码简洁; 派生类可以自行实现覆盖虚函数

	b. 注意事项：
		1. 为什么构造函数不能使用虚函数 ?
			[构造函数是不会被派生类继承的，所以虚函数没用]
			[构造函数没有创建对象前没有生成虚函数表，所以虚函数在构造函数之前无效]

		2. 析构函数声明为虚函数的必要性 ?
			[大部分情况下，析构函数必须声明为虚函数]
			class People {
				public:
					People(){ m_name=new char[100];};
					~People(){delete[] m_name;};
				public:
					char* m_name;
			}

			class Teacher: public People{
				public:
					Teacher() { m_title=new char[100];};
					~Teacher(){ delete[] m_title};
				public:
					char* m_title;
			}

			int main(int argc, char* argv) {
				People p1 = new Teacher();  // 内存泄漏，调用的是基类People的析构函数
				delete p1;
				Teacher p2 = new Teacher();  
				delete p2;
				return 0;
			}

	c. 多态的条件
		1. 继承关系
		2. 基类指针/引用调用派生类
		3. 继承关系中存在原型相同的虚函数

	D. 纯虚函数
		1. 作用: 
			-- 约束派生类应实现哪些功能。
			-- 基类未实现的部分功能给子类去实现。
			[这些功能往往是基类不需要，或者无法实现的功能]

		2. 声明：virtual [返回值] [函数名] [(形参表)] = 0;
		3. 具有纯虚函数类是抽象类，抽象类不能实例化。

	E. 单继承的虚函数表	-- [虚成员函数的实现原理]
		1. 编译器生成代码时维护一个指向虚函数表的指针.
		2，每个类的虚函数表随着继承过程中的重写覆盖掉基类相同原型的函数.
		3. 代码解析:
			p1->display();  // 这里display() 是一个虚函数
			编译器处理为：
			(*(*( p1 + vftoffset ) + vfuncOffset))(p1);

			--  *( p1 + vftoffset )  // 虚函数表的入口
			--  *(*( p1 + vftoffset ) + vfuncOffset) // 虚函数表中被调用的虚函数
			--  参数中的p1用于赋值给this指针

		4. 虚继承时涉及到虚基类表更加复杂

E. 类型识别 [typeid运算符]
	a. typeid用法:
		1. typeid(类型)
		2. typedid(表示式)
		3. 常用来比较两个类型是否一样  typeid(A)=typeid(B);

	b. 使用typeid操作符时，会把类型信息存到tyoeinfo中去， 编译器只为同一个类型生成一个type_info对象
		1. const type_info info = typeid(A);

	c. type_info标准定义四个必须有的成员变量,不同编译器实现不一样.
		1. != 重载函数
		2. == 重载函数
		3, before() 判断一个类型是否位于另外一个类型前面
		4. name() 表示传入类型的字符串
	d. type_info对象的构造函数是private, 所以不能在代码中实例化，只能由编译器内部实例化(借助友元)

F. typeId的多态 [运行时的类型识别机制 RTTI]
	a. 问题: 基类指针通过虚函数表实现了成员函数的多态，那么基类指针如何实现类型的多态(即：typeid)呢？
		1. 在虚函数表前添加type_info的指针指向存放当前类型的信息的结构体。
		2. 类没有虚函数时并不会创建 type_info 结构体信息
		3. **(p+vftoffset-1) // 获取类型信息
	
	b. 问题: 为什么只能在运行识别呢？
		1. 因为指针的指向，可以在运行时赋值，修改，所以类型识别在编译时做不了
	
	c. 多态是付出代价的：更多的存储空间，间接访问等问题。

G. 动态绑定和静态绑定
	a. 静态绑定: 编译时期确定函数/变量的地址 
	b. 动态绑定: 编译时期无法确定函数/变量的地址[RTTI等]

H. C++类相关结构信息【大块头】
	a. 多继承冗余问题 - 虚继承 - 虚基类表
	b. 多态派生类成员函数访问问题 - 虚函数表
	c. 类型识别 - type_info 结构体
	d, 继承链信息数组
	e, 基类信息数组






































