A. C++源文件的后缀: cpp、cxx、cc、c++、C
B. GCC支持其他语言的编译。针对不同的语言推出了不同的命令，例如g++命令用来编译 C++，gcj命令用来编译 Java，gccgo命令用来编译Go语言。
C. C/C++代码生成过程：【源码】 ->  编译  -> 【目标代码】 -> [启动代码]- 链接 -[库代码]  -> 【可执行代码】 	
D. 命名空间
	a. 定义：namespace name{ //variables, functions, classes }
	b. 标准：
		1. 保留C的头文件，兼容旧程序。
		2. 对于不带.h的头文件，所有的符号都位于命名空间 std 中，使用时需要声明命名空间 std。
		3. 对于带.h的头文件，没有使用任何命名空间，所有符号都位于全局作用域。
	c. 使用：函数内部声明std 

E. Const的差别
	a. C语言对const的处理和普通变量一样，会到内存中读取数据；
	b. C++对const的处理更像是编译时期的#define，是一个值替换的过程。
	c. C++中, const全局变量的可见范围仅限于当前文件中
	d. C++中, extern扩大const可见范围 extern const int n=10; 这种方式只适用于 GCC，不适用于 VS/VC。

F. 内存
	int *p = new int[10];  //分配10个int型的内存空间
	delete[] p;
	
G. inline
	a. 在函数定义处添加inline关键字，在函数声明处添加inline关键字没有错，但这种做法是无效的。
	b. 对函数作 inline 声明只是程序员对编译器提出的一个建议，而不是强制性的。
	c. 推荐使用内联函数来替换带参数的宏。
	d. 和宏一样，内联函数可以定义在头文件中, 不用加static关键字，并且头文件被多次#include后也不会引发重复定义错误。	
	e. 内联函数的声明和定义分散到不同的文件中会出错。
		1. 编译期间会用它来替换函数调用处，编译完成后函数就不存在了
		2. 链接器在将多个目标文件（.o或.obj文件）合并成一个可执行文件时找不到 func() 函数的定义，会产生链接错误。
	f. 非内联函数是禁止定义在头文件中的。
	
H. C++函数的默认参数: 
	a. 一旦为某个形参指定了默认值，那么它后面的所有形参都必须有默认值
	b. 多次声明同一函数
		1. 在给定的作用域中一个形参只能被赋予一次默认参数
		2. 函数的后续声明只能为之前那些没有默认值的形参添加默认值，而且该形参右侧的所有形参必须都有默认值。
			void func(int a, int b, int c = 36);   // OK
			void func(int a, int b = 5, int c);	   // 不能再给c赋予默认值
			
I. 函数重载
	a. C语言不能出现同名函数
	b. C++函数重载的依据
		1. 同名函数
		2. 参数列表顺序，类型，个数不同
		3. 返回类型可相同可不同
	c. C++函数重载的二义性
		1. 精确匹配: 从数组名到数组指针、从函数名到指向函数的指针、从非const类型到const类型
		2. 类型提升: 不会丢失信息。
			所有类型提升
			[bool、char、short]=>int
			[char16_t]=>int
			[char32_t]=>long 
			[wchar_t]=>long long	
		3. 类型转换: 不能保证数据的正确性，也不能保证应有的精度。
		4. 编译器二义性：先是精确匹配，然后是类型提升，最后才是类型转换；在某个优先级中找到唯一的一个重载函数就匹配成功。
			失败例1:
			void func(char, int, float);
			void func(char, long, double);
			short n = 99;
			func('@', n, 99.5);
			
			失败例2:
			void func(int);
			void func(double);
			long n = 1000;
			func(n);		
	d. 函数重载原理： C++代码在编译时会根据参数列表对函数进行重命名
		
J. 类和对象
	a. 类只是一个模板,编译后不占用内存空间,所以在定义类时不能对成员变量进行初始化，因为没有地方存储数据。
	b. 成员函数和普通函数区别：
		1. 成员函数是一个类的成员，出现在类体中，它的作用范围由类来决定；
		2. 普通函数是独立的，作用范围是全局的，或位于某个命名空间内。
	c. 类体中和类体外定义成员函数的区别:
		1. 在类体中定义的成员函数会自动成为内联函数，
		2. 在类体外定义的不会成为内联函数
		3. 类体外定义inline函数，必须将类的定义和成员函数的定义都放在同一个头文件中
	d. 类定义: 	
		1. 类的声明和成员函数的定义
		2. 在实际开发中，我们通常将类的声明放在头文件中，而将成员函数的定义放在源文件中。
		3. 成员变量大都以m_开头，这是约定成俗的写法，不是语法规定的内容。
		4. 既不写private也不写public，默认为private
		5. 在一个类体中，private 和 public 可以分别出现多次。每个部分的有效范围到出现另一个访问限定符或类体结束为止
	e. 对象的内存模型:
		1. 成员变量和成员函数分开存储：分别为每个对象的成员变量分配内存，但是所有对象都共享同一段函数代码。
		2. 对象和结构体非常类似，也会有内存对齐的问题
	f. 函数编译原理和成员函数的实现:
		1. C++函数在编译时会根据它所在的命名空间、它所属的类、以及它的参数列表（也叫参数签名）等信息进行重新命名，这过程叫做名字编码（Name Mangling）
		2. 声明而不定义函数，调用函数时产生链接错误，从报错信息中就可以看到新函数名
		3. 成员函数最终被编译成与对象无关的全局函数。
		4. 成员函数中使用到了成员变量该怎么办呢？
			成员变量的作用域不是全局，不经任何处理就无法在函数内部访问。
			C++规定，编译成员函数时要额外添加一个参数，把当前对象的指针传递进去，通过指针来访问成员变量。
			编译前:
			void Demo::display(){
				cout<<a<<endl;
				cout<<b<<endl;
			}
			obj.display();
			编译后:
			void new_function_name(Demo * const p){
				//通过指针p来访问a、b
				cout<<p->a<<endl;
				cout<<p->b<<endl;
			}
			new_function_name(&obj);
			通过传递对象指针就完成了成员函数和成员变量的关联
	g. 类实际上是一个作用域
		1. 在类内部声明定义不用使用类名修饰。
		2. 在类外声明定义返回值，函数名需要使用相应的类名修饰。
		
	h. class与struct的区别
		1. struct成员默认public, class成员默认pravite
		2. class继承默认是private继承，而struct继承默认是public继承
		3. class可以使用模板，而struct不能。
			
K. 构造/析构/this/static/const/友元
	a. 编译器只有在必要的时候才会生成默认构造函数，它的函数体一般不为空。默认构造函数的目的是帮助编译器做初始化工作，而不是帮助程序员。这是C++的内部实现机制，
	b. 初始化参数表:
		1. 成员变量的初始化方式只和类中的声明顺序相关
		2. 使用参数初始化表并没有效率上的优势，仅仅是书写方便
		3. 初始化const变量
	c. this指针：
		1. 访问类所有成员。
		2. 创建对象时由编译器隐式处理给this赋值，不同的对象this不同。
		3. 相关：成员函数的实现原理
	d. static成员：
		1. static成员变量的内存既不是在声明类时分配，也不是在创建对象时分配，而是在（类外）初始化时分配。
		2. 没有在类外初始化的 static 成员变量不能使用。 初始化：int Student::m_total = 10;
		3. 静态成员函数与普通成员函数的根本区别：
			普通成员函数有 this 指针，可以访问类中的任意成员
			而静态成员函数没有 this 指针，只能访问静态成员
		4. 静态成员在声明时要加 static，在定义时不能加 static
		5. 静态成员只能通过类名访问
	e. const成员
		1. const成员函数可以访问所有成员，但不能修改它们
		2. 对象定义为const对象之后，就只能调用类的 const 成员
	f. 友元关系
		0. 实际用得很少
		1. 友元关系不能继承
		2. 友元关系是单向的
		3. 友元函数中不能直接访问类的成员，必须要借助对象。【在友元函数内对象可以访问类的所有成员】
		4. 例子：
		   class Student{
			public:
				Student(char *name, int age, float score);
			public:
				friend void show(Student *pstu);  //将show()声明为友元函数
				friend void School::show(Address *addr);
				friend class teacher;
			private:
				char *m_name;
				int m_age;
				float m_score;
		   };
		
L. 引用与指针
	a. 引用的本质:
		int a = 99;
		int &r = a;	
		r = 18;
		cout<<&r<<endl;
		
		int a = 99;
		int *r = &a; // 引用基于指针实现，引用是占内存.
		*r = 18;
		cout<<r<<endl; // 编译器进行隐式处理对引用区地址返回的是被引用对象的地址。
	
	b. 引用与指针的区别：
		1. 引用只有一级,  指针可以char** p
		2. 只能初始化一次, 指针可以改变指向
		3. 引用是对值进行自加，指针是指向下一个数据。
		4. 引用不支持 int & cosnt p;
	
	c. 临时数据: 
		1. 寄存器中的数据，常量表达式会产生临时数据（没法寻址，意味着不能写操作）。
		2. 常量表达式在编译阶段就能求值。编译器会将常量表达式的值和代码合并到一起，放到虚拟地址空间中的代码区。
		3. 从汇编的角度看，常量表达式的值就是一个立即数，会被“硬编码”到指令中，不能寻址。
		4. 普通引用不能绑定临时数据。【普通引用能进行读写操作，对临时数据进行写没啥意义】
		5. const限定引用可以绑定到临时数据。【const限定引用只能进行写操作】
		6. 临时数据与临时变量是不同
	
	d. 引用/指针与临时数据
		1. 指针只能指向内存，不能指向寄存器或者硬盘，因为寄存器和硬盘没法寻址。
		2. 在GCC下，引用不能指代任何临时数据，不管它保存到哪里；
		3. 在Visual C++下，引用只能指代位于内存中（非代码区）的临时数据，不能指代寄存器中的临时数据。
	
	e. 引用与类型转换
		1. 引用的类型和数据的类型不一致时,如果它们的类型是相近的，并且遵守「数据类型的自动转换」规则
		2. 编译器就会创建一个临时变量，并将数据赋值给这个临时变量（发生自动类型转换），然后再将引用绑定到这个临时的变量
	
	f. 函数参数如果不需要对入参进行修改，尽可能使用const限定引用。
		1. 避免错误的数据修改
		2. 接收consth和非const参数传入，不然只接受非const
		3. 正确的处理临时数据问题
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
