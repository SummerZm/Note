## **C++项目组件绝缘技巧：减少编译时依赖**
> **绝缘 insulation 通常称为“封装”的过程类似，绝缘是指避免或消除不必要的编译时耦合的过程.** 

### **从封装到绝缘**
> **绝缘是一个物理设计问题，它的逻辑相似物一般称为封装**

- **封装是分层次的**
    1. 2.2节类的封装
    2. 3.6节基于组件的封装
    3. 5.10节基于在一个层次结构子系统头文件的文件作用域中定义的类的封装
    4. 上述情况主要涉及以下重要方面：
        ```sh
        # a. 某细节是某实体的一部分。
        # b. 从该实体的接口不能编程访问到该细节。
        ```
- **绝缘相关内容**
    1. **一个被包含的实现细节如果被修改、添加或者删除时不会迫使客户程序重新编译，则这样的实现细节被绝缘了**
        ```sh
        # 什么是不绝缘？接口不变修改了接口的实现导致客户端要重新编译。
        # 封装与绝缘
        #   1. 封装比喻成围绕一个类的实现的极薄的透明膜，用与防止通过编程来访问类的实现。
        #   2. 绝缘意味着是一个无限厚的不透明的障碍，排除了与组件的实现进行直接交互作用的任何可能性。
        # 绝缘的好处：
        #  1. 大型系统的各种层次的内部版本之间发生错误时，修补绝缘组件要比修补没有绝缘的组件容易得多。
        #  2. 没有改变的接口而言，修改后的实现可以放在适当的位置，而不需要重新编译其他组件或者担心头文件过时
        #  3. 绝缘允许我们透明地替换动态装载的库。客户所要做的只是重新配置环境以指向新的动态装载库。
        ```
- **编译时耦合结构隐藏的含义**
    1. **继承**
        ```sh
        # 现实：一个类无论何时派生自另一个类，即使是私有派生，也可能没法把客户程序与之绝缘。
        # 原因：每个客户程序都要见到基类的定义。
        #
        # 使用私有继承的两大原因：a. 使用时虚拟函数表，实现多塔； b. 使用哑元类。（分层节省空间）
        # 做法：使用分层而不是继承的方式。持有基类的指针。
        ```
    2. **分层（Has a）**
        ```sh
        # 结构：当一个类在其定义中嵌入了另一个用户自定义类型的一个实例时（Has A）
        # 现实：客户程序必须知道嵌入对象的定义，所以无法绝缘；但当类只拥有一个对象的地址时可以实现绝缘。
        # 原因：Hold a关系不必依赖该对象的物理布局，Has a关系需要知道嵌入对象的物理布局。
        # 做法：对于性能不大重要的数据成员，可以把（Has a）关系改成（hold a）关系。代价是：间接调用，动态分配，指针管理带来的性能损耗。 
        # 补充：使用（Has a）关系往往和内联函数一起搭配使用，用以提高性能。
        ```
    3. **内联函数**
        ```sh
        # 结构：如果某函数要当前组件之外替换为内联的，那么声明为 inline 的这个函数必须定义在头文件中。
        # 现实：以下情况都是非绝缘的。
        #   a. 能使用该组件的任何程序员都能看到内联实现。
        #   b. 改变一个内联函数的实现会或将内联改为非内联，非内联改为内联将迫使定义内联函数的组件的所有客户程序重新编译。
        #   c. 从一个内联函数通过值返回的一个对象被实质地应用在头文件或者头文件的函数体中也会破坏绝缘。
        #
        # 原因：
        #   a. 在头文件函数中值返回对象实例（即in size），需要知道该对象的物理布局，需要包含对应的头文件
        #   b. 在头文件函数中返回对象的指针或应用但在函数头中通过该引用或指针访问了该类型的数据成员实例，则需要其具体的物理布局，所以无法绝缘。
        ```
        ```C++
        // 内联函数与绝缘相关例子
        #ifndef INCLUDED_FRED
        #define INCLUDED_FRED
        
        #ifndef INCLUDED_WILMA
        #include "wilma.h"
        #endif

        #ifndef INCLUDED_MRSLATE
        #include "mrslate.h"
        #endif

        clase Barney;   // 声明
        clase Betty;    // 声明

        class Fred {
            Wilma *d_wilma_p;
            Barney *d_barney_p;
            Betty *d_betty_p;
            Mrslate *d_mrslate_p;
        public:
            Fred();
            // inline and value-return, need know the definition of Wilma.
            // 内联函数 Wilma 会被展开到使用该组件客户程序里去。客户程序需要感知该类型，需要包含对应头文件定义
            // 因为我们所以不绝缘。
            Wilma getWilma() const { return *d_wilma_p; }   
            Betty getBetty() const; // non-inline function. 
            const Barney& getBarney() const { return *d_barney_p;} // 不透明指针没有实质使用，客户程序不需要感知该类型，绝缘。
            double getSalary() {return d_mrSlate_p->ask();} // 通过指针或引用实质访问该类型的对象，不绝缘。
        }

        #endif
        ```
        ```sh
        # 如何对私有成员函数进行绝缘？
        # 现实：私有成员函数的两种作用？
        #   1. 操作私有数据：
        #   2. 作为助手函数：
        # 做法：
        #   1. 将私有成员函数转化为自由静态函数。
        #   2. 如果操作私有数据成员，可在提供响应的公共访问接口，而自由静态函数接受，私有数据的输入参数。
        #   3. 如果私有数据成员是自定义类型，可以把自定义类型的定义放到C文件里去。
        #   4. 为了降低CCD，可以把静态自由函数独立出去成为一个组件。
        # 补充：尽管在编译时，静态自由函数比私有函数有优势，但运行时性能有所损耗
        ```
    4. **私有成员**
        ```sh
        # 现实：
        #   一个类的每个私有数据成员 - 尽管封装好了 - 也没有与该类的客户程序绝缘。即使很小的代码调整如：将 int 改为 short int。
        #   仅改变一个类的私有成员函数的基类也足以迫使定义该类的组件的所以客户程序重新编译。
        # 原因：私有成员不是绝缘的。
        ```
    5. **保护成员**
        ```sh
        # 结构：
        #   保护接口为预期的派生类作者提供了方便的地方，可以查看并决定什么是需要的。
        #   像私有成员一样，保护接口是在类定义中声明的，因而就一般用户（例如：客户端程序）而言，它不是一个绝缘的实现细节。
        #   因为派生类作者和公共用户都能看到保护成员，暴露类细节。
        # 
        # 影响：以任何方式修改一个基类的保护接口
        #   a. 基类的全部客户程序.   
        #   b. 所有的派生类.
        #   c. 派生类的所有客户程序.
        #
        # 做法：析取协议
        #
        ```
    6. **编译器生成的函数**
        ```sh
        # 影响: 重新声明覆盖已有的编译器默认生成的函数，会造成客户端程序重新编译。
        ```
    7. **包含指令**
        ```sh
        # 影响：
        #   为了防备我们可能用到某种类的定义，所以包含了相应的头文件，这种方法有相对较小的有优点
        #   但我们将永远受潜在的大量头文件的支配。P273
        ```
    8. **默认参数**
        ```sh
        # 影响：单个算法经常依赖于数个参数，将这些默认值放置到定义函数的头文件中可以简化自我建档，
        #   而这些值的任何修改将强迫客户程序重新编译。
        ```
    9. **枚举类型**
        ```sh
        # 现实：
        #   1. 枚举类型、CPP宏、typedef和（默认的）非成员const数据都没有外部的链接，如果想对外面则必须放在头文件中。
        #   2. 一般情况下，组件们都会包含一个共同定义的文件。
        #   3. 这样无论何时将一个共同定义添加到这个共同定义的文件中，系统中几乎所有组件都将被迫重新编译。
        #   4. 最后，添加全局定义代价太昂贵，因此不再这个文件中放置有用的定义（例如：枚举之类的东西），而是反复使用以前已存在的代码，即使它们是模糊甚至是不适当的。
        #
        # 原因：枚举类型和typedef 不是实现细节，而是一个组件的公共接口普通部分，它不是一个抽象良好的，内聚表达，而是一些细节折中的大杂烩。P274
        ```













