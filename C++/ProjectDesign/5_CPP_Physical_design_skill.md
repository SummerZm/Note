## **C++ 大型项目设计解耦技巧**

### **C++缺陷设计简述**
- **未预见到的客户需求可能会使我们在增强系统时考虑不周，从而导致不必要的循环依赖**
    1. **允许两个组件通过#include指令彼此‘知道’隐含了循环物理依赖。**
    2. **例子：Rectangle 和 window 两个类对象，有截然不同的性能特征，但包含着相同的逻辑信息。客户程序偶尔需要在这两类盒子之间转换**
        ```sh
        # 实现互相转换的几种做法 
        # A. 两个类的头文件引入对方的头文件。会产生循环物理依赖。- 不可层次化
        # B. 两个类的C文件引入对方的头文件。会产生非循环物理依赖。- 可层次化【减少编译连接时的性能时间，提高模块的独立性】
        # C. 支配：选一个组件提它的层次，让其依赖另一个组件。- 只有一个组件可以独立使用，高层次组件无法独立使用 【片面】
        # D. 升级：在两个组件之上设置一个新组件，该组件位于它们之上一个层次，并且包含它们。
        #    重点：同层次的组件是循环依赖的，那么就有可能把互相依赖的功能从每一个组件升级为潜在的新的更高层次的组件(依赖于每一个初始的组件)的静态成员。P185
        ```
- **相关抽象接口中的内存耦合使他们更抗拒层次分解。**
    1. 为了避免出现封装缺口和由于远距离友元关系导致的缺乏模块性，可能有必要将若干可层次化的类归入一个单一的组件内。

### **C++物理设计解耦技巧**
- **一个不小心的功能增强使得组件间出现了循环依赖 P186 P197**
    1. **升级：把相互依赖的功能推到物理层次结构的更高层来消除循环依赖。**
        ```sh
        # 实现：将底层子模块，组件之间的转换或者工厂关系通过静态成员结构的方式提取出来有利于编译，链接，分层测试和组件解耦
        ```
    2. **降级: 把相互依赖的功能推到物理层次结构的低层来消除循环依赖。**
        ```sh
        # 方法1：可以对功能重新打包，这样可以恢复单向依赖。【这些组件的客户程序可能受影响 - p172】
        # 方法2：将两个或多个静态工具中产生依赖的部分抽成一个独立的组件。而这些组件通过特殊方式（实现继承等）与该核心组件建立链接。
        ```
- **不透明的指针**
    1. **什么是不透明指针？**
    ```sh
    # 如果一个指针所指向的类型的定义不包含在当前的编译单元中，这个指针就被称为是不透明的。
    # 涉及只在名称上使用一个类型的情况很少会自然出现，这样做只是为了避免不必要的物理依赖。
    ```

    2. **不透明指针的应用场景**
    ```sh
    # 如果一个被包含的对象拥有一个指向它的容器的指针，并且要实现那些实质地依赖那个容器的功能，那么我们可以通过以下方法来消除相互依赖。
    # 第1：让被包含的指针不透明。
    # 第2：在被包含类的公共接口上提供对容器指针的访问。
    # 第3：将被包含类的受影响的方法升级为容器类的静态成员。
    ```
    3. **总结升华**
    ```sh
    # 通过使用 Widgest 类的内部 Screen 指针不透明，以及把Widget中实质使用了 Screen 类的那部分移出 Widget, 移入Screen类本身。
    # 我们能够获得一张非循环的组件依赖图。我们也在widget的公共接口上暴露了 Screen 类型，并且使 widget 的客户必须在那个组件之外寻找问题答案。
    # 但这样做的时候，相互的物理依赖被概念上的协作所取代：较低趁此机的对象只同意保持在较高层次上使用的信息（只在名称上指定）。
    #
    # 哑数据是不透明指针的一种泛化，它有助于子系统的实现。在子系统中低层次的对象必须隐含地引用其他低层次对象。 P215
    # 应用场景：某些引用在子系统的较低层次不必解释，而只在某个较高层次的对象的上下文中解释。在这种受约束的上下文中，尽管会损害类型安全和封装但实现可以更简洁。
    ```

- **冗余 (Manager类的作用)**
> **通过使用冗余数据和不透明指针来减少CCD**

- **ShapeManager 和 不透明指针的使用减少 CCD. P218**

- **回调**  
    1. **应用场景总结**
    ```sh
    # 优点： 
    # 1. 回调函数由用户提供给较低层次组件调用。该函数通常需要较高层次的上下文。
    # 2. 虚函数可以用来实现一个类型安全的回调机制。 【orderedPointCollection 虚基类的使用 P223】
    # 3. 回调函数是打破协同类之间的依赖并降低CCD的强有力工具【P227 星系例子】。对图形学和基于事件程序设计是及其重要的。
    # 
    # 缺点：
    # 1. 不适当地使用回调会模糊低层次对象的职责并导致不必要概念上的耦合。【P225 数据库例子】
    # 2. 比传统的函数调用更难以理解，维护和调试。
    # 3. 他们的伪异步特性需要开发人员给予一种不同类型的关注。
    # 4. 回调应该被当作是最后求助的避难所。
    ``` 

- **管理类**
    1. **应用场景总结**
    ```sh
    # a. 类的实例之间时常出现的循环互相连接似乎在暗示，这种循环属性应该反映在一个系统的物理设计中。对于本质上紧密耦合
    #    其定义有很容易适应于单个组件的小型循环依赖对象的网络来说，也许没有理由要消除这样的循环
    #       以公司为例：正规雇员不会彼此雇佣和解雇，这种职权是给管理者保留的。
    #       
    # b. 避免循环物理依赖的有效技术就是让所有指向较高层次组件的指针和应用都是只在名称上。
    #       让类 edge 支配 node。做法让Node hold不透明Edge指针的一个集合（这意味着所有涉及边的实质问题都不能在node层解答）
    ```

- **分解**
    1. **分解并不会解析循环依赖，而是将组件中没有依赖的部分分离，通用的形式是继承，结果是循环依赖被抬高一层**
        ```sh
        # 在循环物理依赖不可避免地方，将其升级到尽可能高的层次可减少CCD,甚至可以使循环能够由一个单个的，大小便于管理的组件代替。
        ```
    2. **通过继承完成分解过程中对于值语义的理解 【重点理解：p237】**
        ```C++
        // 配合书中的背景逻辑理解。[哪些对象在实现关系上有被复制的意义。从现实生活中的场景去设计书写代码]
        void f(const Graph& g)
        {
            const Gnode& a = g.node("Zurich"); 
            Gnode b = g.node("London");  // error
            Node& c = g.node("Paris");
            Node d = g.node("Tokyo");
            a = b;          // error
            c = d;
        }
        ```
    3. **分解之后上层组件中友元关系的处理 【p245】**
        ```sh
        # 分解过程中其他知识杂谈
        # a. 管理者（权职清晰便于管理）。
        #
        # b. 分层时，底层指向高层的不透明引用（相比于指针确保一定有值），解耦解依赖提高可测性。
        # 
        # c. 分解过程中值语义与成员变量，与构造，赋值函数的关系。（有些关系理论上可行，但与现实关系不符，写代码是服务于现实。就像讲话，有些话是不合时宜的）
        #
        # d. 友元的使用方法
        #     在单个组件中使用，避免远距离友元关系。
        #     将被调用的友元类函数最好声明为private，避免被滥用。
        #       例子：在管理类下，子组件的创建销毁都由管理类决定。这会使用友元关系时，需将子组件类构造，析构声明为私有。防止子组件脱离控制。
        ```
    4. **总结**
        ```sh
        # 分解是一种通用技术。可用来减少有着固有循环依赖设计的维护开销。通过将一些实现复杂事物重新安装到较低层次组件中，
        # 可以独立于余下的循环互相依赖代码对该功能进行测试或者重用。 一般的分解会得到更灵活的体系结构。又不会牺牲运行时效率。
        # 然而，在分解一个子系统的接口时，客户可能被要求使用子系统层次结构中较低层次的组件接口。
        # 注：分解和降级是不同的。
        ```

- **升级封装**
    1. **合理的将组件封装成子系统 【p237】**
    ```sh
    # 试图按“每个组件”的原则封装一个子系统的实现，可能会妨碍低层次的通信和/或破坏一个其他的可行设计。
    # 比限制单独类中的客户可访问功能更好的是，我们可以限制在总的子系统接口中暴露给用户类的子集。通过使用一个包装器组件。
    # 我们可以将封装的层次升级到子系统的最高层，这样做可以消除对低层次友元关系的需要，从而也消除了将紧密耦合的类合成单个的超大型组件的必要。
    #
    # 分析：
    # 包装的缺点是：接口不灵活，是遍历它的通信更慢。一个被包装的子系统开始开发时也可能开销更大
    # 但是，包装可能是使包含有许多高度互相依赖组件的子系统完成层次化和封装的唯一真正有效途径。
    #
    # 后话：如何把客户程序与包装器组件下面的实现类型的编译时依赖绝缘？
    ```







































