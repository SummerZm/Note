## **C++ 大规模程序设计**
> **逻辑设计研究体系结构问题，物理设计研究组织问题**

### **物理设计概念简介**
- **逻辑关系-依赖**
    1. **逻辑设计决策如何潜在的影响物理依赖。**
    2. **如何从已存在的组件中提取物理依赖。**

- **物理层次结构**
    1. **如何根据物理依赖来刻画单个组件，子系统和整个系统的特性。**
    2. **如何通过隔离，增量，分层次的测试来获得可靠的物理层次结构。**
    3. **定量分析了系统中物联依赖在时间和磁盘空间维护的开销和回归测试的影响。**
    
- **链接依赖的常见原因**
    1. **减少一个系统链接时依赖的若干技术和变换。**

- **过多编译时耦合的维护开销**
    1. **减轻或消除个别编译时依赖的技术。**

- **层次化的概念拓展到超大型系统 - 包**

### **组件基本逻辑**
- 一个组件是物理设计和逻辑设计的基本单位。中间层也可以是一个组件。
- 一个组件的物理接口是指头文件中暴露的所有东西。
- 一个组件的逻辑接口是被用户编程使用或者测试的东西。
- 设计一个组件要考虑的问题？
    1. 考虑哪些逻辑实体应该天然的在一起或者充分互相依赖，不能被合理分割
    2. 考虑物理接口上需要暴露多少实现细节
    3. 考虑我们组件需要依赖哪些其他组件？这些组件会带来的影响。

### **物理设计规则**
- **一个组件内部声明的实体不应该在组件之外定义**
- **组件的c文件应该将自己的h文件放在自身文件有效代码的第一行**
    1. 作用：如果编译不过可在h文件中添加相应的类型声明，确保组件自身的头文件对于编译来说都是自包含的。

### **指导方针**
- **避免依赖一个头文件去包含另一个头文件**
    1. 更好理解的解释：
        ```sh
        # 现象：接口x() 在a.h中声明；b.h包含了a.h; c.h 需要使用到 x()接口，包含了b.h。
        # 以上: c.h 依赖 b.h 去包含 a.h 中的 x()。 
        # 问题：b.h 一旦改动，就gg了。
        ```
    2. 如何将一个类型在另一个类型上分层，这将影响编译时的耦合程度。修改分层的实现挺危险的。
        ```sh
        # 分层：has a 和 hold a 逻辑关系.
        # hold a：头文件声明要hold的类型.
        # has a：头文件要include 该类型的头文件.
        ``` 

- **避免使用有外部链接但没有在头文件中明确声明的定义**
    1. 这种隐晦的带后门式的代码。在使用过程中，可能会形成很隐晦的依赖.
    2. 更过分的做法是把整个类的定义都包含在c文件中，这样的代码不方便直接测试.
    3. 进一步演变，避免通过局部声明来使用另一个组件中的外部声明定义.而是要包含该组件的头文件声明定义.

### **依赖关系**
> **一个组件可能在编译时不必依赖另一个组件，而在连接时要依赖它**

- **编译时的依赖，链接时的依赖，依赖关系的传递**
1. 编译时依赖:
    ```sh
    # 定义：组件A中代码文件中的符号在组件B的代码文件中定义，则组件A编译依赖于组件B。
    # 例子：组件A使用的外部符号在组件B中使用，则组件A对组件B有编译时的依赖。
    ```

2. 链接时依赖:
    ```sh
    # 定义: 组件A中目标文件的覆盖在组件B的目标文件中实现，则组件A链接依赖于组件B。
    # 例子：组件A编译依赖于组件B，组件B编译依赖于组件C，则组件A链接依赖于组件C。 组件C依赖。
    ```

3. 依赖传递：长的编译依赖链传递过程会形成链接依赖。即：编译时没报错，链接时报错了。

- **逻辑设计和物理特性之间的隐含关系**
> **因为逻辑设计产生了不和需要的物理特性，而被迫修改甚至重做逻辑设计**
1. 逻辑关系 uses [函数参数，返回值使用了某种类型]
    ```sh
    # Uses 常常隐含着一个编译时依赖。
    # Uses 几乎总是隐藏着一个链接时依赖。
    # use in interface。
    ```

2. 逻辑关系 is-a: 
    ```sh
    # use in implementation
    ```

3. 逻辑关系 has-a: 
    ```sh
    # use in implementation
    ```

4. 总结：
    ```sh
    # is-a 和 has-a 逻辑实体之间关系，在跨越组件边界实现时总是隐含编译时依赖。【原因：直接是使用类型的实体，需要分配空间。所以在编译时必须知道类型的定义】
    # uses 和 holds-a 逻辑实体之间关系可能隐含跨越组件的链接时依赖。 【原因：引用/指针并不需要知道具体的类型定义，它们往往只是个地址，所以不会产生编译时依赖】
    # 我们可以远在编写任何代码之前就评价出我们的体系结构的物理质量。
    ```

- **提取实际依赖**
1. 如果系统编译成功，仅凭C++预处理器#include指令产生的包含图，就足以推断出系统内部所有物理依赖。

- **友元关系**
> **具有友元关系的逻辑实体。可以访问相关类的私有数据**
1. **避免把友元关系授权给定义在另一个组件中的逻辑实体 - 避免远距离友元关系。**
2. **一个组件内部的友元关系是该组件的一个实现细节**
    ```sh
    # 1. 把组件（而不是）类视为设计的基本单位，只要友元关系被局部授权，那么这些友元事实上就与授权友元的对象不可分割。
    # 2. 上面的局部授权：指的是将友元函数授权给定义在相同组件内的逻辑实体。
    # 3. 即把存在友元关系的类定义放在同一个头文件中。（好处：如果试图提供友元类其他定义，编译时会报错）。
    ```
3. **运算符函数当成类成员，还是当成自由函数好？**
    ```sh
    # 类成员时：逻辑接口的一部分，会有物理上的依赖，往往需要放在同一文件中。同时成员函数的参数和返回值的use关系容易形成依赖环
    # 自由函数：不是类逻辑接口的一部分，可以独立放在另外文件。【函数参数返回值是应用或者指针，并不会产生编译时依赖】
    ```

4. **一个组件的友元关系是该组件的一个实现细节**
    ```sh
    # 一个组件数据类的迭代器实现方式可以是：友元关系，hold-a逻辑关系，或者其他。
    ```

5. **友元关系影响访问特权但不隐含依赖；可能是会破坏封装函数。**
6. **友元关系不是组件的逻辑接口**
    ```sh
    # 友元关系影响访问特权但不隐含依赖；可能是会破坏封装函数。
    # 友元关系可高效方便的访问友元类的成员；破坏了封装性；和use,is-a,has-a一样，是一种实现细节。
    # 友元函数破坏封装性的例子：
    #   自由远距离的友元函数，可被第三方组件以local函数的形式覆盖重写，泄密。
    #   全局自由函数都有被第三方组件以文件local函数覆盖重写的可能，因为组件文件内作用域优先级高于全局。
    ```










