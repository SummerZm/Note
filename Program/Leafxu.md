## **计算机的一些心得**

### 《程序员的自我修养》
#### **计算机发展过程**
- **计算机发展的过程围绕的主题**  
    1. 性能高效性：发展分时操作系统，多用户多线程操作系统，单核到多核硬件的发展。
    2. 安全稳定性：物理内存地址空间到虚拟内存地址空间，分段，分页。
    3. 工程拓展性：各种外设驱动的设配。

- **三大主题发展简介**
    1. 性能高效性
        ```sh
        # CPU避免闲置
        #  A. 多进程操作系统的引入,避免阻塞CPU空转,充分利用硬件资源 VS 资源抢占调度问题。
        #  B. 多线程的引入，避免进程空转，充分利用进程的时间片 VS 内存数据访问问题/进程的阻塞浪费。
        #     备注：用户层线程需要内核层线程支持；其实现方式： 1对1， 1对多， 多对多。
        #  C. 协程的引入，避免线程空转，在用户空间不陷入内核空间，减少上下文切换，充分利用线程的时间片 VS 内存数据访问问题/线程的阻塞浪费。
        #  D. 单核到多核的引入，多核上的进程或进程级线程可以实现并行 VS 资源抢占调度问题。
        #     备注：2004年已经达到单核性能顶峰4Ghz步入多核时代。
        #
        # 内存的置换的颗粒度
        #  A. 分页机制：内存不够时不用整个程序置换，换出局部。VS 内存管理的复杂度
        ```
    2. 安全稳定性
        ```sh
        # 内存共享问题
        #  A. 物理内存地址管理改成虚拟地址 VS 进程间共享完整物理地址空间，不安全。
        #     备注：32位的cpu有32根地址线索引2^32=4G大小的地址空间 
        # 
        # CPU并发各层面问题
        #  A. 软件层面： 锁，可重入函数；避免多进程/多线程分在某些顺序运行造成误修改。
        #  B. 编译器层面： volative；避免编译器动态优化，将数据直接放在寄存器内。
        #  C. 硬件层面：原子指令 和 barrier指令；避免CPU乱序执行优化。
        ```

    3. 工程拓展性
        ```sh
        # 内存布局
        #  A. 编译器将代码翻译成程序时需要进行内存布局，便于程序运行加载到内存合适的位置。分段机制提供了良好的加载时重定位机制。
        ```

#### **可执行文件结构布局**
- **可执行文件的生成过程**
    1. 预处理：-E 
    2. 编译：-S 生成汇编代码
    3. 汇编：-C 生成机器码
    4. 链接：-O 生成可执行或目标文件

- **可执行文件的组成成分**  
    1. 可执行文件格式的起源
        ```sh
        # window的FE (Portable Executale) 和 linux的ELF（Executable Linkable Format）都源自于 COEF（Common Executable Format）格式的变种
        ```
    2. 开发人员编写的代码   【代码段/数据段/等】
        ```sh
        # A. 代码指令放在.text段。
        # B. 初始化全局变量和静态变量放在.data段。
        # C. 未初始化全局变量和静态变量一般情况放在.bss段。
        # D. 可以将数据放在自己指定的段内，也可以自定义数据段。
        ```
    3. 可执行文件适用的系统硬件平台信息 【文件头】
        ```sh
        # A. 可执行文件的头含有适用的硬件架构信息，cpu位长等
        # B. 各种段落实到内存上的权限分布
        # C. 代码段和数据段分开存放的原因
        # D. 同样代码段可以被多个进程共享【动态库】
        ```
    4. 可执行文件的自描述信息 【文件头/段表/字符串表/符号表/重定向表】
        ```sh
        # A. 如何看懂段表？
        # B. 如何看懂符号表？
        # C. 如何看懂ELF文件头？
        # D. 如何看懂字符串表？
        # E. 如何找到重定位表
        # F. 如何使用弱符号/弱引用？
        # G. 为什么C++的不同编译器编出的模块不能互相链接？
        ```

    5. 链接器脚本链接时给可执行文件添加的符号 

#### **静态链接细节**
- **空间与地址分配**
    1. 空间分配：将多个目标文件的相同段合并
    2. 地址分配：按照多个目标文件相同段的大小长度分配相对地址
- **符号解析与重定位**
    1. 符号解析：为目标文件中的符号分配合适的地址
    2. 重定位：为重定位表/段中的符号，按表/段中指定的指令修正方式进行重定位，计算合适的地址。【注：即使是同平台同指令也有多种寻址方式 p109】
- **COMMON类型与符号问题**
    1. COMMOM类型针对一个符号在所有目标文件中都是弱符号的情况。链接器会选择空间较大的分配地址 【注：解决链接无法识别符号相同但类型不同的弱符号问题】
    2. 符号问题：
        ```sh
        # A. 同一链接对象集：多个相同强符号。 --> [ld报错]
        # B. 同一链接对象集：多个相同符号，一强多弱。 --> [ld使用强符号]
        # C. 同一链接对象集：多个相同弱符号。 --> [ld使用COMMOM类型]
        ```
- **静态链接及其控制过程** 
    1. 最小程序
    ```sh
    # A. 编译使用 --no-builtin 参数表明不使用 编译器内置的函数。
    # B. 链接使用 -e 指定函数入口。
    # C. 代码使用汇编，表明不使用C库函数，避免C库让链接器生成 .start .fini之类的段。
    ```
    2. 链接器控制脚本过程
    ```sh
    # A. 常见的链接器控制过程
    #     a. 命令行参数
    #     b. 在目标文件中放置链接参数
    #     c. 指定链接脚本 -T（链接脚本专门的语法可以把段和并成一个，也可以调整函数出入口地址）
    #
    # B. 如何查看链接的详细信息：ld -verbose
    # C. 如何查看静态编译链接的详细信息： gcc --verbose .....
    # D. 链接器ld会抽取库中的相应的目标文件进行链接避免生产的可执行文件过大。[这依赖于库的良好组织形式和代码工程结构]
    ```    
- **BDF库简介**
    1. 现代硬件和软件平台的兼容问题。
        ```sh
        # A. CPU 的位数：8位，16位，32位，64位
        # B. CPU 的字节序问题
        # C. 有无MMU
        # D. 是否支持动态链接
        # E. 是否支持对齐
        # F. 是否支持调试
        # 注： 造成了各种各样的目标文件格式
        ```
    2. BDF库致力于解决上述问题，目前gcc工具都通过BDF库来处理目标文件问题。

- **C++相关问题**
    1. 重载多态特性使得合并重复代码花费代代价更大。-- 【函数级别链接】
    2. 全局构造和析构。 -- 基于 _start 和 .init .fini段实现
    3. 更难做到二进制ABI（application Binary Interface）兼容。
        ```sh
        # C语言角度决定目标文件之间的二进制兼容。
        #
        #
        # C++语言角度决定目标文件之间的二进制兼容。
        #
        #
        # 注：ABI兼容问题根源既来自于硬件，软件操作系统，编译器，链接器，编程语言等因素。
        ```








