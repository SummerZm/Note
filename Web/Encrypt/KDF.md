## **秘钥安全与KDF简介**

### **密码加密与破解发展历史**
- HASH算法 **【单向映射不用明文比对】**
    1. 原理：hash函数是用来做「向指定大小的空间映射的一个工具」。不管密码有多长，最终都被映射到了一个固定大小的空间中。
    2. 破解：彩虹表 [收集目标空间的字符串形成表格] 多次哈希在彩虹表面前只是弟弟
    3. 彩虹表：攻击者可以不断收集人类产生的密码，计算它的hash，从而建立起hash到密码的反向查询表（彩虹表）

- salt盐值 **【应对彩虹表】**
    1. 场景a: 用户设置的密码太简单
    2. 本质：随机数
    3. 原理：
        ```sh 
        # A. hash两次三次，对于彩虹表来说，根本不算什么事嘛！根本的原因在于，输入的密码复杂度过低，来源空间的可能性太小。
        # B. 密码虽然复杂度不高，但是加的salt可以随机生成，只要最终计算hash时，使用salt和密码的结合，即可充分利用目标空间。
        # C. 这样，彩虹表就失效了，因为salt的可能性非常多。理论上，salt的空间需要大于hash空间，才能有效覆盖目标空间。当然，这个salt自然是需要明文读取的。
        ```
- KDF **【验证端数据库被攻破】**
    1. 场景a: 一旦验证端数据库被攻破，salt很可能也就知道了，虽然彩虹表没有效了，但是由于密码本身复杂度不高，攻击者依然可以暴力破解密码。
    2. 原理： 为了应对暴力破解，hash函数被设计成了很占用资源的方式。
    3. 案例：
        ```sh
        # a. PBKDF2常用的设置里有成千上万次迭代，来消耗CPU资源，但是被最近的GPU计算，FPGA计算大大地削弱了防护能力。
        # b. Linux系统密码采用的bcrypt，Litecoin使用的scrypt则消耗大量内存资源，可以用来对抗GPU计算。
        # c. 最新的Argon2，则可以同时消耗大量内存和大量CPU。
        ```

