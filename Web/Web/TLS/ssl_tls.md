## **通信中的SSL 与 TLS**

### **一、写在前面**
- **通信中的问题**
    1. 窃听风险: 第三方可以获知通信内容 [解决：加密机制]
    2. 篡改风险：第三方可以修改通信内容 [解决：校验机制]
    3. 冒充风险：第三方可以冒充他人身份参与通信 [解决：身份证书]

- **解决方案**
    1. 出于性能,效率考虑，我们使用对称加密通信解决
    2. 出于以上三个风险考虑，要解决对称加密的公钥泄漏问题，我们使用CA认证
    3. 出于每个通信会话公钥要随机，允许使用不同的加密算法，我们使用TLS协议进行通信协商

- **知识体系**  
    1. 对称加密与非对称加密
    2. CA认证机制与证书链
    3. **【本文重点】TLS协议工作流程**

- **相关链接**
    1. https://www.ruanyifeng.com/blog/2014/02/ssl_tls.html

### **二、TLS协议历史**
- 1994年，NetScape公司设计了SSL协议（Secure Sockets Layer）的1.0版，但是未发布。
- 1995年，NetScape公司发布SSL 2.0版，很快发现有严重漏洞。
- 1996年，SSL 3.0版问世，得到大规模应用。
- 1999年，互联网标准化组织ISOC接替NetScape公司，发布了SSL的升级版TLS 1.0版。
- 2006年和2008年，TLS进行了两次升级，分别为TLS 1.1版和TLS 1.2版。最新的变动是2011年TLS 1.2的修订版。
- TLS 1.0通常被标示为SSL 3.1，TLS 1.1为SSL 3.2，TLS 1.2为SSL 3.3。
- 应用最广泛的是TLS 1.0，接下来是SSL 3.0。但是，主流浏览器都已经实现了TLS 1.2的支持。

### **三、SSL/TLS协议的基本过程**
- A. 客户端向服务器端索要并验证公钥  **[细节:通过传输CA机制证书，认证服务器。公钥在证书中]**  
    **1. 重点：TLS与CA的结合使用。**  
    **2. 认证：此阶段进行服务器/客户端的单向or双向证书认证（认证方式可选）**  
    **3. 协商：a. 通过CA证书传输协商公钥(用于加密随机数)；b. 协商对称加密通信使用的算法**  

- B. 双方协商生成"对话密钥"  **[细节：依赖于步骤A中生成的随机数]**  
    **1. 细节: 步骤A中确保了服务器/客户端持有相同的随机数，用协商后的算法各自生成新的对称加密公钥，用于实际通信**  
    **2. 实际需求：步骤A中加密方式，压缩算法的协商是为了提供更好的兼容性**  
    **3. 实际需求:出于安全考虑，不同的会话需要使用随机的不同的对称加密公钥**  

- C. 双方采用"对话密钥"进行加密通信。

### **四、SSL/TLS协议的握手细节**
    
 ![tls.png](tls.png)

 - **客户端发出请求（ClientHello）**
    ```sh
    # ClientHello请求: 客户端主要向服务器提供以下信息。
    # 1. 支持的协议版本，比如TLS 1.0版。
    # 2. 一个客户端生成的随机数，稍后用于生成"对话密钥"。
    # 3. 支持的加密方法，比如RSA公钥加密。
    # 4. 支持的压缩方法。

    # 注意：2006年，TLS协议加入了一个Server Name Indication扩展，允许客户端向服务器提供它所请求的域名。
    # 为虚拟主机用户解决“通常一台服务器只能有一张数字证书”问题。
    ```

- **服务器回应（SeverHello）**
    ```sh
    # SeverHello回应: 
    # 1. 确认使用的加密通信协议版本，比如TLS 1.0版本。如果浏览器与服务器支持的版本不一致，服务器关闭加密通信
    # 2. 一个服务器生成的随机数，稍后用于生成"对话密钥"。
    # 3. 确认使用的加密方法，比如RSA公钥加密。
    # 4. 服务器证书 （带有公钥）。
    # 5. 要求客户端提供"客户端证书" (如果开启了双向认证)
    ```
- **客户端回应**
    ```sh
    # 验证服务器CA证书。如果证书没有问题，客户端就会从证书中取出服务器的公钥。然后，向服务器发送下面三项信息。
    # 1. 一个随机数（pre-master key）。该随机数用服务器公钥加密，防止被窃听。
    # 2. 编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。
    # 3. 客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供服务器校验。
    ```
- **服务器的最后回应**
    ```sh
    # 服务器收到客户端的第三个随机数pre-master key之后，计算生成本次会话所用的"会话密钥"。然后，向客户端最后发送下面信息
    # 1. 编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。
    # 2. 服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供客户端校验。
    ```

- **如何计算会话密钥**
    1. 通信之后，客户端和服务器就同时有了三个随机数，接着双方就用事先商定的加密方法，各自生成本次会话所用的同一把"会话密钥"。
    2. 用三个随机数来生成"会话密钥"：
        ```sh
        # 1. 有必要引入一种随机因素来保证协商出来的密钥的随机性
        # 2. SSL协议不信任每个主机都能产生完全随机的随机数，客户端和服务器加上pre master secret三个随机数一同生成的密钥就不容易被猜出
        ```
