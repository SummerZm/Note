## 数据库范式 ##
> 能不能使用数据库的范式来指导面向对象编程？

### 范式简介 ###
1. 1NF， 2NF，3NF, BCNF, 4NF, 5NF。
2. 键：能唯一标识元组的属性集叫做超键。
3. 候选键：如果超键不包括多余的属性，那么这个超键就是候选键。
4. 主键：用户可以从候选键中选择一个作为主键。
5. 外键：如果数据表 R1 中的某属性集不是 R1 的主键，而是另一个数据表 R2 的主键，那么这个属性集就是数据表 R1 的外键。
6. 主属性：包含在任一候选键中的属性称为主属性。
7. 非主属性：与主属性相对，指的是不包含在任何一个候选键中的属性。

### 第一范式 1NF ###
- 不能表中有表，任何DBMS都能支持1NF

### 第二范式 2NF###
- 2NF 指的数据表里的非主属性都要和这个数据表的候选键有完全依赖关系。
- 完全依赖不同于部分依赖，也就是不能仅依赖候选键的一部分属性，而必须依赖全部属性。
    ```SQL
        -- 例子：
        -- 表字段：球员编号、姓名、年龄、比赛编号、比赛时间、比赛场地
        -- 候选键：球员编号，比赛编号
        -- 决定关系：(球员编号, 比赛编号) -> (姓名, 年龄, 比赛时间, 比赛场地，得分)
       
        -- 部分依赖：
        -- 球员编号 -> （姓名, 年龄）
        -- 比赛编号 -> （ 比赛时间, 比赛场地，得分）

        -- 影响：

        -- 结论：不满足范式2NF，需要拆分数据表

### 第三范式 3NF###
- 3NF 在满足 2NF 的同时，对任何非主属性都不传递依赖于候选键。
- 传递依赖
    ```SQL
        -- 表字段: 球员编号、姓名、球队名称、球队主教练
        -- 候选键：球员编号
        -- 决定关系：（球员编号）-> (姓名、球队名称 -> 球队主教练)
        -- 存在传递依赖
    ```
### 巴斯范式BCNF 3NF###
- 在3NF 的基础上消除了主属性对候选键的部分依赖或者传递依赖关系
- 分析例子
    ```SQL
    -- 数据表: 管理员、物品名、仓库名、数量
    -- 前提：一个仓库只有一个管理员，同时一个管理员也只管理一个仓库。
    -- 依赖关系：
        -- 仓库名和管理员互相依赖
        -- 仓库名和物品名决定数量
        -- 综上：
            -- 候选键是（管理员，物品名）和（仓库名，物品名）【可以从候选键中任选一个当主键】
            -- 主属性是（管理员，仓库名，物品名）
            -- 非主属性是 数量
    -- 范式
        -- 每个属性都是原子性的，符合1NF
        -- 非主属性”数量“都与候选键全部依赖，（仓库名，物品名）决定数量，（管理员，物品名）决定数量，数据表符合2NF
        -- 数据表中的非主属性，不传递依赖于候选键。符合3NF

    -- 问题
        -- 增加一个仓库，但是还没有存放任何物品。主键不能有空值，因此会出现插入异常；
        -- 如果仓库更换了管理员，我们就可能会修改数据表中的多条记录；
        -- 如果仓库里的商品都卖空了，那么此时仓库名称和相应的管理员名称也会随之被删除。
    
    -- 原因: 主属性仓库名对于候选键（管理员，物品名）是部分依赖的关系
    -- 解决：仓库表：（仓库名，管理员）库存表：（仓库名，物品名，数量）
    ```

### 反范式设计 ###
- 数据库：主要用于实时数据更新。【OLTP-范式】
- 数据仓库：主要用于数据分析，挖掘。【OLA片-反范式优化】
- 