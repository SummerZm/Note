## 数据库常见问题 ##

### <b>外键的性能影响</b> ###

1. 超大型的数据应用场景，大量的插入，更新和删除在外键的约束下会降低性能
2. 数据库在水平拆分和分库的情况下，数据库端也做不到执行外键约束
3. 在高并发的情况下，每次更新数据，外键都需要检查另外一张表的数据，容易造成死锁

### <b>COUNT()的效率</b> ###
1. MyISAM 的数据表都有一个meta信息有存储了row_count. 统计数据表的行数只需要O(1)复杂度, 一致性由表级锁来保证.
2. InnoDB支持事务，采用行级锁和MVCC机制,无法维护row_count, COUNT(*)采用全表扫描，进行循环+计数的方式进行统计.
3. 在InnoDB引擎中，采用COUNT(*)和COUNT(1)来统计数据行数，要尽量采用二级索引.
4. 查找行用主键索引【聚簇索引】
5. 不查找具体的行用占用空间更小的二级索引【非聚簇索引】
6. COUNT(*) = COUNT(1) > COUNT(字段)

### <b>聚集函数问题集合</b>###
1. COUNT(role_assist)会忽略值为NULL的数据行，而 COUNT(*) 不会NULL

### <b>语法问题集合</b> ###
1. 使用表的别名，在查询字段中就只能使用别名进行代替，不能使用原有的表名
2. SQL语句最后以分号（;）作为结束符
3. 表创建SQL语句最后一个字段的定义结束后没有逗号

### <b>数据库可移植性问题</b> ###
- MySQL在Linux的环境下，数据库名、表名、变量名是严格区分大小写的 
- MySQL在Windows的环境下全部不区分大小写
- MySQL在Windows/Linux的环境下字段名是忽略大小
- 建议格式：
    1. 关键字和函数名称全部大写
    2. 数据库名、表名、字段名称全部小写

### <b>SQL语句连接查询执行顺序</b> ###
- 先进行笛卡尔积
- FROM(ON) > WHERE > GROUP BY > (聚合函数) > HAVING > SELECT 的字段 > DISTINCT > ORDER BY > LIMIT

### <b>SQL视图相关问题集</b> ###
- SQLite 不支持视图的修改，仅支持只读视图。如果想要修改视图，就需要先 DROP 然后再 CREATE。
- 有些DBMS不支持的视图不支持索引，MYSQL支持。

### <b>SQL事务问题集</b> ###
- Oracle 事务默认不自动提交，需要手写 COMMIT 命令，MySQL 默认自动提交
- 脏读、不可重复读和幻读这三种异常情况是在SQL-92标准中定义的，同时SQL-92标准还定义了4种隔离级别来解决这些异常情况。

### <b>mysql索引相关问题</b> ###
- 在 MySQL 中支持两种排序方式，分别是 FileSort 和 Index 排序。
- 在 Index 排序中，索引可以保证数据的有序性，不需要再进行排序，效率更高。
- FileSort 排序则一般在内存中进行排序，占用 CPU 较多。如果待排结果较大，会产生临时文件 I/O 到磁盘进行排序的情况，效率较低。
- 避免全表扫描在 WHERE 子句和 ORDER BY 子句中使用索引>
- ORDER BY排序: 单索引> 联合索引 > FileSort
