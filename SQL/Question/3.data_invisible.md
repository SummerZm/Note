## **为什么数据改了，查询却仍不可见？**
> **事务支持是在引擎层实现的，MySQL 是一个支持多引擎的系统，但并不是所有的引擎都支持事务**  

### **事务隔离**
- 当数据库上有多个事务同时执行的时候，就可能出现脏读（dirty read）、不可重复读（non-repeatable read）、幻读（phantom read）的问题。
- 为了解决这些问题，就有了“隔离级别”的概念。
    1. 读未提及：当前事务没提交，其他事务也能读到改动。
    2. 读已提交：当前事务提交了，其他事务才能读到改动。
    3. 可重复读：其他事务，改动不会影响，本事务。本事务从数据库里读到的值一直没改变。
    4. 串行化


### **你可能会问那什么时候需要“可重复读”的场景呢？**
    ```sh
    # 一个表存了账户余额，一个表存了账单明细。到了月底你要做数据校对，也就是判断上个月的余额和当前余额的差额，是否与本月的账单明细一致。
    # 你一定希望在校对过程中，即使有用户发生了一笔新的交易，也不影响你的校对结果。
    #
    # 事务启动时的视图可以认为是静态的，不受其他事务更新的影响。
    ```

### **注意事项**
- 【迁移】Oracle 的默认隔离级别是“读提交”，对于从 Oracle 迁移到 MySQL 的应用，为保证数据库隔离级别的一致，要记得将 MySQL 的隔离级别设置为“读提交
- 【版本】在 MySQL 5.5 及以前的版本，回滚日志是跟数据字典一起放在 ibdata 文件里的，即使长事务最终提交，回滚段被清理，文件也不会变小。
    ```sh
    # 见过数据只有 20GB，而回滚段有 200GB 的库。最终只好为了清理回滚段，重建整个库。
    # 文件已经被撑大，因为有数据字典，又不能删除，但回滚段的空间可以重新分配用于其他数据。 
    #
    # 其他： 文件删除了磁盘空间仍没，降下来的原因是有其他进程持有该文件的句柄。
    ```
- 【编码】有些客户端连接框架会默认连接成功后先执行一个 set autocommit=0 的命令。这就导致接下来的查询都在事务中，如果是长连接，就导致了意外的长事务
    ```sh
    # 使用 commit work and chain 语法。在 autocommit 为 1 的情况下，用 begin 显式启动的事务
    # 如果执行 commit 则提交事务。
    # 如果执行 commit work and chain，则是提交事务并自动启动下一个事务，这样也省去了再次执行 begin 语句的开销
    ```
    
    
    
    
    
