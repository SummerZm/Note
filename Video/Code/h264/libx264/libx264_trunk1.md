## **libx264主干接口代码调用**
> **[雷神](https://blog.csdn.net/leixiaohua1020/article/details/45644367)**

### **x264_encoder_open()** 
- x264_sps_init()：根据输入参数生成H.264码流的SPS信息。
- x264_pps_init()：根据输入参数生成H.264码流的PPS信息。
- x264_predict_16x16_init()：初始化Intra16x16帧内预测汇编函数。[扫描方式]
- x264_predict_4x4_init()：初始化Intra4x4帧内预测汇编函数。
- x264_pixel_init()：初始化像素值计算相关的汇编函数（包括SAD、SATD、SSD等）。
    ```sh
    # 像素计算中的概念
    # SAD和SATD主要用于帧内预测模式以及帧间预测模式的判断。有关SAD、SATD、SSD的定义如下：
    # 1. SAD（Sum of Absolute Difference）也可以称为SAE（Sum of Absolute Error），即绝对误差和。
    #       它的计算方法就是求出两个像素块对应像素点的差值，将这些差值分别求绝对值之后再进行累加。
    # 2. SATD（Sum of Absolute Transformed Difference）即Hadamard变换后再绝对值求和。
    #       它和SAD的区别在于多了一个“变换”。
    # 3. SSD（Sum of Squared Difference）也可以称为SSE（Sum of Squared Error），即差值的平方和。
    #       它和SAD的区别在于多了一个“平方”。
    #
    # H.264中使用SAD和SATD进行宏块预测模式的判断。早期的编码器使用SAD进行计算，近期的编码器多使用SATD进行计算。
    # 为什么使用SATD而不使用SAD呢？
    # 关键原因在于编码之后码流的大小是和图像块DCT变换后频域信息紧密相关的，而和变换前的时域信息关联性小一些。
    # SAD只能反应时域信息；SATD却可以反映频域信息，而且计算复杂度也低于DCT变换，因此是比较合适的模式选择的依据。
    #
    # 使用SAD进行模式选择。使用Vertical，Horizontal，DC和Plane四种帧内预测模式预测的像素。
    # 通过计算可以得到这几种预测像素和原始像素之间的SAD（SAE）分别为3985，5097，4991，2539。
    # 由于Plane模式的SAD取值最小，由此可以断定Plane模式对于这个宏块来说是最好的帧内预测模式。
    #
    ```
- x264_dct_init()：初始化DCT变换和DCT反变换相关的汇编函数。
    ```sh
    # DCT变换的核心理念
    # 1. 把图像的低频信息（对应大面积平坦区域）变换到系数矩阵的左上角
    # 2. 把高频信息变换到系数矩阵的右下角
    # 3. 这样就可以在压缩的时候（量化）去除掉人眼不敏感的高频信息（位于矩阵右下角的系数）从而达到压缩数据的目的。
    ```
- x264_mc_init()：初始化运动补偿相关的汇编函数。
    ```sh
    # x264_mc_init()中包含了大量的像素内插、拷贝、求平均的函数。这些函数都是用于在H.264编码过程中进行运动估计和运动补偿的。# x264_mc_init()的参数x264_mc_functions_t是一个结构体，其中包含了运动补偿函数相关的函数接口。
    ```
- x264_quant_init()：初始化量化和反量化相关的汇编函数。
    ```sh
    #
    # A. 量化是H.264视频压缩编码中对视频质量影响最大的地方，也是会导致“信息丢失”的地方。
    #
    # B. Qstep越大，视频压缩编码后体积越小，视频质量越差。
    #       量化：FQ=round(y/Qstep)
    #     反量化：y’＝FQ*Qstep
    #
    # C. 《H.264标准》中规定，量化过程除了完成本职工作外，还需要完成它前一步DCT变换中“系数相乘”的工作。
    #       |Zij| = (|Wij|*MF + f)>>qbits
    #       sign(Zij) = sign (Wij)
    #
    #    sign()为符号函数。 Wij为DCT变换后的系数。
    #    MF的值需要查表。表中只列出对应QP 值为0 到5 的MF 值。QP大于6之后，将QP实行对6取余数操作，再找到MF的值。
    #    qbits计算公式为“qbits = 15 + floor(QP/6)”。即它的值随QP 值每增加6 而增加1。
    #    f 是偏移量（用于改善恢复图像的视觉效果）。对帧内预测图像块取2^qbits/3，对帧间预测图像块取2^qbits/6。
    ```
- x264_deblock_init()：初始化去块效应滤波器相关的汇编函数。
    ```sh
    # 原因： 
    # 1. DCT量化
    # 2. 运动补偿
    #
    # 环路滤波分类
    # 1. 环路滤波器根据滤波的强度可以分为两种：
    #   普通滤波器。针对边界的Bs（边界强度）为1、2、3的滤波器。
    #   此时环路滤波涉及到方块边界周围的6个点（边界两边各3个点）：p2，p1，p0，q0，q1，q2。需要处理4个点（边界两边各2个点，只以p点为例）：
    #       p0’ = p0 + (((q0 - p0 ) << 2) + (p1 - q1) + 4) >> 3
    #       p1’ = ( p2 + ( ( p0 + q0 + 1 ) >> 1) – 2p1 ) >> 1
    #   强滤波器。针对边界的Bs（边界强度）为4的滤波器。
    #   此时环路滤波涉及到方块边界周围的8个点（边界两边各4个点）：p3，p2，p1，p0，q0，q1，q2，q3。需要处理6个点（边界两边各3个点，只以p点为例）：
    #       p0’ = ( p2 + 2*p1 + 2*p0 + 2*q0 + q1 + 4 ) >> 3
    #       p1’ = ( p2 + p1 + p0 + q0 + 2 ) >> 2
    #       p2’ = ( 2*p3 + 3*p2 + p1 + p0 + q0 + 4 ) >> 3
    #
    # 环路滤波的门限
    #   1. 不是所有的块的边界处都需要环路滤波。例如画面中物体的边界正好和块的边界重合的话，就不能进行滤波，否则会使画面中物体的边界变模糊。因此需要区别开物体边界和块效应边界。
    #   2. 一般情况下，物体边界两边的像素值差别很大，而块效应边界两边像素值差别比较小。《H.264标准》以这个特点定义了2个变量alpha和beta来判决边界是否需要进行环路滤波。
    #   3. 只有满足下面三个条件的时候才能进行环路滤波：
    #       | p0 - q0 | < alpha
    #       | p1 – p0 | < beta
    #       | q1 - q0 | < beta
    #
    #   简而言之，就是边界两边的两个点的像素值不能太大，即不能超过alpha；
    #   边界一边的前两个点之间的像素值也不能太大，即不能超过beta。其中alpha和beta是根据量化参数QP推算出来（具体方法不再记录）。
    #   总体说来QP越大，alpha和beta的值也越大，也就越容易触发环路滤波。由于QP越大表明压缩的程度越大，所以也可以得知高压缩比的情况下更需要进行环路滤波。
    #
    # 边界强度Bs的判定方式：
    #   ------------------------------------------------------------------
    #   条件（针对两边的图像块）                         Bs
    #   ------------------------------------------------------------------
    #   有一个块为帧内预测 + 边界为宏块边界               4
    #   有一个块为帧内预测                               3
    #   有一个块对残差编码                               2
    #   运动矢量差不小于1像素                            1
    #   运动补偿参考帧不同                               1
    #   其它                                            0
    #   ------------------------------------------------------------------
    #
	# 方块的横向边界的滤波，即如下所示：
	#          p2
	#          p1
	#          p0
	#   =====图像边界=====
	#          q0
	#          q1
	#          q2
	#
	# 对应的是方块的横向边界的滤波，即如下所示：
	#            ||
	#   p2 p1 p0 || q0 q1 q2
	#            ||
    ```
- x264_ratecontrol_new()：初始化码率控制相关的变量。
- mbcmp_init()：决定像素比较的时候使用SAD还是SATD。
    ```c
    //b_lossless一般为0
    //主要看i_subpel_refine，大于1的话就使用SATD
    int satd = !h->mb.b_lossless && h->param.analyse.i_subpel_refine > 1;
    ```

### **x264_encoder_headers()**
> 在输出每个NALU之前，需要调用x264_nal_start()，在输出NALU之后，需要调用x264_nal_end()。
- x264_sps_write()
- x264_pps_write()
- x264_sei_version_write()















